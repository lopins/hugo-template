<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Huabing Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://images.unsplash.com/photo-1473186578172-c141e6798cf4?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1973&amp;q=80"><meta property="twitter:image" content="https://images.unsplash.com/photo-1473186578172-c141e6798cf4?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1973&amp;q=80"><meta name=title content="Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理"><meta property="og:title" content="Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理"><meta property="twitter:title" content="Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理"><meta name=description content="Aeraki Mesh 提供了对 Redis 的流量管理能力，可以实现客户端无感知的 Redis Cluster 数据分片，按 key 将客户端请求路由到不同的 Redis 服务，读写分离，流量镜像，故障注入等高级流量管理功能。"><meta property="og:description" content="Aeraki Mesh 提供了对 Redis 的流量管理能力，可以实现客户端无感知的 Redis Cluster 数据分片，按 key 将客户端请求路由到不同的 Redis 服务，读写分离，流量镜像，故障注入等高级流量管理功能。"><meta property="twitter:description" content="Aeraki Mesh 提供了对 Redis 的流量管理能力，可以实现客户端无感知的 Redis Cluster 数据分片，按 key 将客户端请求路由到不同的 Redis 服务，读写分离，流量镜像，故障注入等高级流量管理功能。"><meta property="twitter:card" content="summary"><meta name=keyword content="赵化冰, zhaohuabing, Zhaohuabing, , 赵化冰的网络日志, 赵化冰的博客, Zhaohuabing Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice"><link rel="shortcut icon" href=/hugo-template/img/favicon.ico><title>Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理 | 赵化冰的博客 | Zhaohuabing Blog</title>
<link rel=canonical href=/hugo-template/post/2023-05-08-manage-redis-with-aeraki-mesh/><link rel=stylesheet href=/hugo-template/css/bootstrap.min.css><link rel=stylesheet href=/hugo-template/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/hugo-template/css/zanshang.css><link rel=stylesheet href=/hugo-template/css/font-awesome.all.min.css><script src=/hugo-template/js/jquery.min.js></script><script src=/hugo-template/js/bootstrap.min.js></script><script src=/hugo-template/js/hux-blog.min.js></script><script src=/hugo-template/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Huabing Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/hugo-template/categories/books/>books</a></li><li><a href=/hugo-template/categories/open-source/>open source</a></li><li><a href=/hugo-template/categories/presentations/>presentations</a></li><li><a href=/hugo-template/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/hugo-template/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.unsplash.com/photo-1473186578172-c141e6798cf4?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1973&q=80)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/aeraki-mesh title="Aeraki Mesh">Aeraki Mesh
</a><a class=tag href=/tags/redis title=Redis>Redis</a></div><h1>Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理</h1><h2 class=subheading></h2><span class=meta>Posted by
赵化冰
on
Tuesday, May 9, 2023</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>Redis 是一种高性能的键值数据库，支持丰富的数据结构和操作，包括字符串、哈希、列表、集合、有序集合等。由于其强大的能力，Redis 被广泛应用于缓存、会话存储、消息代理等场景中。</p><p>Aeraki Mesh 提供了对 Redis 的完善的流量管理能力，可以实现客户端无感知的 Redis Cluster 数据分片，支持按 key 将客户端请求路由到不同的 Redis 服务，还提供了读写分离，流量镜像，故障注入等能力。本文将使用 Aeraki Mesh 自带的 Demo 来演示如何使用 Aeraki Mesh 来对 Redis 进行流量管理。</p><h1 id=系统架构>系统架构</h1><p>Aeraki 和 Istio 工作在控制面，数据面则由 Envoy sidecar 组成。Aeraki 在控制面提供了 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RedisService</a> 和 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RedisDestination</a> 两个用户友好的 Kubernetes CRD 来作为面向运维的操作接口，并将用户配置的流量规则转换为数据面配置，通过 xDS 下发到 Envoy Sidecar。Envoy Sidecar 拦截客户端的 Redis 访问请求，并根据控制面下发的配置提供相关的流量管理能力。
<img src=https://zhaohuabing.com/static/img/2023-05-08-manage-redis-with-aeraki-mesh/aeraki-redis.png alt></p><h1 id=安装示例程序>安装示例程序</h1><p>首先从 github 下载 Aeraki Mesh 的源码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/aeraki-mesh/aeraki.git
</span></span></code></pre></div><p>安装 Istio 和 Aeraki。Aeraki 是基于 Istio 的，所以需要先安装 Istio。Aeraki 的安装脚本会自动安装 Istio，所以只需要执行 Aeraki 的安装脚本即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>make demo
</span></span></code></pre></div><p>在 Aerkai 代码目录下执行 redis demo 的安装脚本，该脚本会创建一个 redis namespace，并在其中部署 redis demo 应用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./demo/redis/install.sh
</span></span></code></pre></div><p>demo 应用中包含一个 6 节点的 redis cluster（statefulset），一个单机模式的 redis，和一个 redis 客户端。后面我们将使用该 demo 来演示 Aeraki Mesh 对 Redis 的流量管理相关功能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n redis get pod
</span></span><span style=display:flex><span>NAME                            READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>redis-client-644c965f48-dvjc7   2/2     Running   <span style=color:#bd93f9>0</span>          2m17s
</span></span><span style=display:flex><span>redis-cluster-0                 1/1     Running   <span style=color:#bd93f9>0</span>          2m17s
</span></span><span style=display:flex><span>redis-cluster-1                 1/1     Running   <span style=color:#bd93f9>0</span>          2m15s
</span></span><span style=display:flex><span>redis-cluster-2                 1/1     Running   <span style=color:#bd93f9>0</span>          2m13s
</span></span><span style=display:flex><span>redis-cluster-3                 1/1     Running   <span style=color:#bd93f9>0</span>          2m12s
</span></span><span style=display:flex><span>redis-cluster-4                 1/1     Running   <span style=color:#bd93f9>0</span>          2m11s
</span></span><span style=display:flex><span>redis-cluster-5                 1/1     Running   <span style=color:#bd93f9>0</span>          2m10s
</span></span><span style=display:flex><span>redis-single-ccbb984dc-qz22v    1/1     Running   <span style=color:#bd93f9>0</span>          2m17s
</span></span></code></pre></div><h1 id=设置-redis-访问密码>设置 Redis 访问密码</h1><h2 id=为-redis-服务设置访问密码>为 Redis 服务设置访问密码</h2><p>demo 中部署的 redis-single 服务设置了访问密码，此时如果通过客户端去访问该服务，redis 服务器会提示需要用户认证，拒绝访问请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>redis-single:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> a a
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> NOAUTH Authentication required.
</span></span></code></pre></div><p>在未使用 Aeraki Mesh 对 Redis 进行流量管理时，客户端代码需要从配置中得知其运行环境中访问的 Redis 服务是否需要进行认证，以及认证的用户名和密码。然后根据配置和 Redis 服务器进行认证，这增加了客户端代码及配置管理的复杂度。</p><p>通过采用 Aeraki Mesh 的 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RdisDestination</a> ，可以设置访问 Redis 的密码，由 Sidecar Proxy 来替客户端和 Redis 服务器进行认证。这样 Redis Client 就无需再关注 Redis 服务的密码信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: v1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: Secret
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-service-secret
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>type</span>: Opaque
</span></span><span style=display:flex><span><span style=color:#ff79c6>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>password</span>: dGVzdHJlZGlzCg==
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisDestination
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-single
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>: redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>trafficPolicy</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>connectionPool</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>auth</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>secret</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>name</span>: redis-service-secret
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>此时再通过客户端访问 redis-single 服务，就可以正常访问了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><h2 id=为客户端设置独立的访问密码>为客户端设置独立的访问密码</h2><p>在某些情况下，我们可能希望客户端使用的访问密码与 Redis 服务的真实密码不同。这样会带来一些好处，比如可以在不影响客户端的情况下更换 Redis 服务密码。这样也减少了 Redis 服务密码暴露的风险。通过配置 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a> ，我们可以单独设置客户端的访问密码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-single
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>settings</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>auth</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>plain</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>password</span>: testredis123!
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>此时访问 redis-single 服务，需要使用 RedisService 中设置的新密码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> ERR invalid password
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis123!
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-single:6379&gt; get foo
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;bar&#34;</span>
</span></span></code></pre></div><blockquote><p>备注：RedisDestination 和 RedisService 中的 auth 字段均支持两种密钥获取的途径：secret 与 plain。secret 代表所需要的用户名、密码信息存在于 Kubernetes secret 资源中。在这种情况下，默认将使用所引用 secret 中定义的 username 的值作为 auth 使用的用户名，password 或 token 作为 auth 时使用的密码。如果使用了 secret 中不同的字段来进行认证，我们通过配置 passwordField 和 usernameField 来指定认证使用的密码和用户名字段。</p></blockquote><h1 id=屏蔽-redis-的部署模式差异>屏蔽 Redis 的部署模式差异</h1><p>Redis 可以部署为单机模式或者 <a href=https://redis.io/docs/reference/cluster-spec/>Cluster 模式</a>。Cluster 模式相对于单机模式有以下优点：</p><ul><li>支持水平扩展，可以通过增加节点数量可提高集群的性能和容量。</li><li>支持自动分区，可以将数据分散到不同的节点上，提高负载均衡和可用性。</li><li>具备一定的容错能力，即使某个节点宕机或网络出现问题，也可以自动进行故障转移和恢复。</li></ul><p>Redis 要求分别采用不同的 client API 访问单机模式和 Cluster 模式。通过采用 Aeraki Mesh 的 Redis 流量管理功能，我们可以在不修改客户端代码的前提下切换后端的 Redis 部署模式，从而降低了应用开发的复杂度。</p><p>比如我们可能在测试集群使用一个小型的单实例 Redis ，而在生产环境使用一个包含多个实例的 Redis Cluster。通过 Aeraki Mesh，我们无需修改应用的代码/配置就可以将应用对接到不同环境的 Redis 服务上，从而尽可能的保证了 <a href=https://12factor.net/zh_cn/>12-Factor 应用</a>中的<a href=https://12factor.net/zh_cn/dev-prod-parity>开发，预发布，线上环境的一致性</a>，实现应用的持续部署。</p><p>Demo 中部署的 Redis Cluster 由 6 台 Redis 服务器组成，Cluster 中有三个分片（Shard），每个分片中有一个 Master 节点，一个 Slave 节点。我们可以通过下面的命令来查看该 Redis Cluster 的拓扑结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it redis-cluster-0 -c redis -n redis -- redis-cli cluster shards
</span></span></code></pre></div><p>该 Redis Cluster 的拓扑结构如下图所示。从图中可以看到，该 Cluster 有三个分片（Shard）每个 Shard 负责一个范围的槽位（Slot），Shard 0 负责处理 Slot 0 到 5460，Shard 1 负责处理 Slot 5461 到 10922，Shard 2 负责处理 10923 到 16383。每个 Key 对应的 Slot 是固定的，其计算方式为 <code>CRC16(key) mod 16384</code>。</p><p>当我们向 Redis Cluster 中写入或者读取数据时，要求客户端根据算法 <code>CRC16(key) mod 16384</code> 计算出数据所属的 Slot，然后将数据发送到对应 Shard 中的节点上。</p><p><img src=https://zhaohuabing.com/static/img/2023-05-08-manage-redis-with-aeraki-mesh/redis-cluster.png alt></p><p>当我们尝试通过 Redis 客户端访问 demo 中部署的 Redis cluster，会出现下面的访问错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> foo bar
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> MOVED <span style=color:#bd93f9>15495</span> 10.244.0.23:6379
</span></span></code></pre></div><p>这是因为 Redis 客户端采用了普通模式的 API。客户端将请求发送到 redis-cluster 服务，然后该请求被随机分发到该服务后端的一个 Redis 节点上。如果该节点不是请求的 key 根据算法算出的 Slot 所在的分片，那么该节点会返回一个 MOVED 错误，告诉客户端应该访问哪个节点。客户端会根据该错误，重新发送请求到正确的节点。但是，由于客户端采用的是普通模式的 API，因此客户端无法解析该错误，也就无法重新发送请求。因此，客户端会一直报错。</p><p>通过配置 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RdisDestination</a> 中的模式为 CLUSTER，Aeraki Mesh 可以为我们屏蔽 Cluster 模式和独立模式的差异。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisDestination
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: external-redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>: external-redis.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>trafficPolicy</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>connectionPool</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>mode</span>: CLUSTER
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>此时我们就可以像访问一个独立 Redis 节点一样访问 redis-cluster 服务了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>采用该方法，我们可以在开发和生产环境中无缝切换，而无需修改应用代码。我们也可以在应用业务规模逐渐扩张，单一 Redis 节点压力过大时，将系统中的 Redis 从单节点无缝迁移到集群模式。</p><p>在集群模式下，不同 key 的数据被缓存在不同的数据分片中，我们可以增加分片中 Replica 节点的数量来对一个分片进行扩容，也可以增加分片个数来对整个集群进行扩展，以应对由于业务不断扩展而增加的数据压力。Aeraki Mesh 通过配置 Envoy 代理了 Redis 的流量，整个迁移和扩容过程对客户端完全透明，不会影响到线上业务的正常运行。</p><h1 id=redis-流量路由>Redis 流量路由</h1><p>采用 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a> ，我们可以根据请求 key 的前缀将流量路由到不同的 Redis 服务上。</p><p>例如下面的 RedisService 将以 <code>cluster</code> 开头的 key 路由到 redis-cluster 服务，其它 key 路由到 redis-single 服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>match</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>key</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>prefix</span>: cluster
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>此时通过客户端访问 redis-cluster 服务，分别设置 <code>test-route</code> 和 <code>cluster-test-route</code> 两个 key 的值。然后这两个 key 的值也可以通过 get 命令获取到。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> test-route <span style=color:#f1fa8c>&#34;this key goes to redis-single&#34;</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> cluster-test-route <span style=color:#f1fa8c>&#34;this key goes to redis-cluster&#34;</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get test-route
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to redis-single&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get cluster-test-route
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to redis-cluster
</span></span></span></code></pre></div><p>再通过客户端访问 redis-single 服务，可以看到 redis-single 服务中只有 <code>test-route</code> 这个 key，而 <code>cluster-test-route</code> 这个 key 的值为 nil。这说明 <code>test-route</code> 被路由到 redis-single 服务，而 <code>cluster-test-route</code> 被路由到 redis-cluster 服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis123!
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-single:6379&gt; get test-route
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to redis-single&#34;</span>
</span></span><span style=display:flex><span>redis-single:6379&gt; get cluster-test-route
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>nil<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><h1 id=redis-读写分离>Redis 读写分离</h1><p>在 Redis Cluster 中有多个分片（Shard），每个 Redis 分片中，通常有一个 Master 节点，一到多个 Slave（Replica）节点。Master 节点负责写操作，并将数据变化同步到 Slave 节点。Slave 节点作为备份节点，当 Master 不可用时，Slave 可以被选举成为新的 Master。由于 Slave 中保存了和 Master 中相同的数据，因此也可以响应客户端的读操作。</p><p>Aeraki Mesh 支持通过 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a> 来为 Redis 设置不同的读策略：</p><ul><li>MASTER： 缺省的读模式。只从 Master 节点读取数据，当客户端要求数据强一致性时需要采用该模式。该模式对 Master 压力较大，在同一个分片内无法采用多个节点对读操作进行负载分担。</li><li>PREFER_MASTER： 优先从 Master 节点读取数据，当 Master 节点不可用时，从 Replica 节点读取。</li><li>REPLICA： 只从 Replica 节点读取数据，由于 Master 到 Replica 的数据复制过程是异步执行的，采用该方式有可能读取到过期的数据，因此适用于客户端对数据一致性要求不高的场景。该模式下可以采用多个 Replica 节点来分担来自客户端的读负载。</li><li>PREFER_REPLICA： 优先从 Replica 节点读取数据，当 Replica 节点不可用时，从 Master 节点读取。</li><li>ANY： 从任意节点读取数据。</li></ul><p>如果客户端对缓存数据不要求强一致性，我们可以把读模式设置为 REPLICA。在该模式下，Master 节点只处理写操作，Slave 节点处理读操作，减少了 Master 节点的工作压力。随着业务的扩展，我们还可以在分片中增加更多的 Replica，以对读操作进行负载分担。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>settings</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>readPolicy</span>: REPLICA  
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><h1 id=流量镜像>流量镜像</h1><p>采用 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a> ，我们可以将发送到 Redis 服务的请求同时发送一份到另一个 Redis 服务上。客户端只会收到来自主 Redis 服务的响应，而镜像 Redis 服务的响应会被丢弃。我们可以设置镜像流量的百分比，例如将 50% 的流量镜像到另一个 Redis 服务上。</p><p>例如下面的 RedisService 将所有发送到 redis-cluster 服务的请求同时发送到 redis-single 服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>mirror</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>host</span>: redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>percentage</span>: 
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>value</span>: <span style=color:#bd93f9>100</span>
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>此时通过客户端访问 redis-cluster 服务，设置 <code>test-traffic-mirroring</code> key 的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> test-traffic-mirroring <span style=color:#f1fa8c>&#34;this key goes to both redis-cluster and redis-single&#34;</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get test-traffic-mirroring
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to both redis-cluster and redis-single&#34;</span>
</span></span></code></pre></div><p>再通过客户端访问 redis-single 服务，可以看到 redis-single 服务中也有 <code>test-traffic-mirroring</code> 这个 key，说明客户端发送给 redis-cluster 的请求被同时发送到了 redis-single。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis123!
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-single:6379&gt; get test-traffic-mirroring
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to both redis-cluster and redis-single&#34;</span>
</span></span></code></pre></div><h1 id=故障注入>故障注入</h1><p>采用 <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a> ，我们可以为 Redis 服务注入故障，该功能可以用于混沌测试等场景，以检验系统是否对于 Redis 故障进行了恰当的容错处理。</p><p>RedisService 支持配置两种类型的故障，分别是：</p><ul><li>延迟(DELAY)：延迟是时间故障。它们模拟增加的网络延迟或一个由于超过负载而反应迟缓的 Redis 服务。</li><li>错误(ERROR)：错误是请求错误。它们模拟异常情况下的 Redis 服务。</li></ul><p>例如，以下配置会使百分之五十的 GET 命令直接返回错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>faults</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>type</span>: ERROR
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>percentage</span>: 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>value</span>: <span style=color:#bd93f9>50</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>commands</span>:
</span></span><span style=display:flex><span>        - GET
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>此时通过客户端访问 redis-cluster 服务，会有一半的 GET 命令返回 <code>Fault Injected: Error</code> 错误信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get a
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> Fault Injected: Error
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get a
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;a&#34;</span>
</span></span></code></pre></div><h1 id=连接集群外-redis-服务>连接集群外 Redis 服务</h1><p>Demo 中的 Redis 是部署在 Kubernetes 集群中的，但其实我们也可以通过 Aeraki Mesh 连接集群外的 Redis 服务。我们可以在 Kubernetes 集群中创建一个 <a href=https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors>无选择器服务</a>，然后创建一个该服务对应的 EndpointSlice 来指定外部 Redis 的地址。然后就可以像集群内服务一样使用 RedisService 和 Redis Destination 来对该服务进行流量管理了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF 
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: v1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: Service
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: external-redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>name</span>: tcp-redis
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: discovery.k8s.io/v1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: EndpointSlice
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: external-redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>kubernetes.io/service-name</span>: external-redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>addressType</span>: IPv4
</span></span><span style=display:flex><span><span style=color:#ff79c6>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: tcp-redis
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span><span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>addresses</span>:
</span></span><span style=display:flex><span>      - <span style=color:#bd93f9>10.244.0.26</span> <span style=color:#6272a4># 集群外 Redis 实例的地址，比如云厂商提供的 Redis 服务。</span>
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><h1 id=小结>小结</h1><p>本文介绍了如何使用 Aeraki Mesh 来对 Redis 进行流量治理，包括流量路由、流量镜像、故障注入等功能。目前该功能已经在 Aeraki 的最新版本中提供，欢迎大家试用并提出宝贵的意见和建议。更多 Redis 流量治理的介绍请参考 Aeraki Mesh 官网教程中的 <a href=https://www.aeraki.net/zh/docs/v1.x/tutorials/redis/>Redis 流量管理</a>。</p><h1 id=参考资料>参考资料</h1><ul><li><a href=https://www.aeraki.net/zh/docs/v1.x/tutorials/redis/>Redis 流量管理</a></li><li><a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a></li><li><a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>Redis Destination</a></li></ul><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://lopins.github.io/hugo-template/><img src=/hugo-template/img/favicon.png>Huabing Blog</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/hugo-template/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/hugo-template/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/hugo-template/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/hugo-template/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/hugo-template/post/2023-04-11-why-eg-is-the-gateway-in-cloud-native-era/ data-toggle=tooltip data-placement=top title="为什么 Envoy Gateway 是云原生时代的七层网关？">&larr;
Previous Post</a></li><li class=next><a href=/hugo-template/post/2023-05-08-manage-redis-with-aeraki-mes-eng/ data-toggle=tooltip data-placement=top title="Database Mesh: Simplify Redis Cluster with Istio and Aeraki">Next
Post &rarr;</a></li></ul><link href=https://xxx.xxx.com/dist/Artalk.css rel=stylesheet><script src=https://xxx.xxx.com/dist/Artalk.js></script><div id=Comments></div><script>Artalk.init({el:"#Comments",pageKey:"https://lopins.github.io/hugo-template/post/2023-05-08-manage-redis-with-aeraki-mesh/",pageTitle:"Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理",server:"https://xxx.xxx.com",site:"xxx blog"})</script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/aeraki title=aeraki>aeraki
</a><a href=/tags/aeraki-mesh title="aeraki mesh">aeraki mesh
</a><a href=/tags/ambient-mesh title="ambient mesh">ambient mesh
</a><a href=/tags/api-gateway title="api gateway">api gateway
</a><a href=/tags/bitcoin title=bitcoin>bitcoin
</a><a href=/tags/blockchain title=blockchain>blockchain
</a><a href=/tags/cka title=cka>cka
</a><a href=/tags/cncf title=cncf>cncf
</a><a href=/tags/cryptocurrency title=cryptocurrency>cryptocurrency
</a><a href=/tags/digital-signature title="digital signature">digital signature
</a><a href=/tags/docker title=docker>docker
</a><a href=/tags/dubbo title=dubbo>dubbo
</a><a href=/tags/envoy title=envoy>envoy
</a><a href=/tags/envoy-gateway title="envoy gateway">envoy gateway
</a><a href=/tags/ingress title=ingress>ingress
</a><a href=/tags/istio title=istio>istio
</a><a href=/tags/jaeger title=jaeger>jaeger
</a><a href=/tags/kafka title=kafka>kafka
</a><a href=/tags/knowledge-graph title="knowledge graph">knowledge graph
</a><a href=/tags/kubecon title=kubecon>kubecon
</a><a href=/tags/kubernetes title=kubernetes>kubernetes
</a><a href=/tags/linux title=linux>linux
</a><a href=/tags/loadbalancer title=loadbalancer>loadbalancer
</a><a href=/tags/metaprotocol title=metaprotocol>metaprotocol
</a><a href=/tags/microservice title=microservice>microservice
</a><a href=/tags/network title=network>network
</a><a href=/tags/network-service-mesh title="network service mesh">network service mesh
</a><a href=/tags/nfv title=nfv>nfv
</a><a href=/tags/nodeport title=nodeport>nodeport
</a><a href=/tags/onap title=onap>onap
</a><a href=/tags/opentracing title=opentracing>opentracing
</a><a href=/tags/pilot title=pilot>pilot
</a><a href=/tags/proxy-protocol title="proxy protocol">proxy protocol
</a><a href=/tags/redis title=redis>redis
</a><a href=/tags/sdn title=sdn>sdn
</a><a href=/tags/security title=security>security
</a><a href=/tags/service-mesh title="service mesh">service mesh
</a><a href=/tags/tencent title=tencent>tencent
</a><a href=/tags/x-forwarded-for title=x-forwarded-for>x-forwarded-for</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:youremail@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/hugo-template/your%20wechat%20qr%20code%20image><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/yourgithub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/yourlinkedinid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/yourstackoverflowid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Huabing Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Huabing Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/hugo-template/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>