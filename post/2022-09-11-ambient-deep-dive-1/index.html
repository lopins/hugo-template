<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Huabing Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://images.unsplash.com/photo-1484976063837-eab657a7aca7?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1740&amp;q=80"><meta property="twitter:image" content="https://images.unsplash.com/photo-1484976063837-eab657a7aca7?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1740&amp;q=80"><meta name=title content="Istio Ambient 模式流量管理实现机制详解（一）"><meta property="og:title" content="Istio Ambient 模式流量管理实现机制详解（一）"><meta property="twitter:title" content="Istio Ambient 模式流量管理实现机制详解（一）"><meta name=description content="赵化冰，程序员, 开源爱好者，生活探险家 | 这里是 赵化冰 的博客，与你一起发现更大的世界。"><meta property="og:description" content="赵化冰，程序员, 开源爱好者，生活探险家 | 这里是 赵化冰 的博客，与你一起发现更大的世界。"><meta property="twitter:description" content="赵化冰，程序员, 开源爱好者，生活探险家 | 这里是 赵化冰 的博客，与你一起发现更大的世界。"><meta property="twitter:card" content="summary"><meta name=keyword content="赵化冰, zhaohuabing, Zhaohuabing, , 赵化冰的网络日志, 赵化冰的博客, Zhaohuabing Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice"><link rel="shortcut icon" href=/hugo-template/img/favicon.ico><title>Istio Ambient 模式流量管理实现机制详解（一） | 赵化冰的博客 | Zhaohuabing Blog</title>
<link rel=canonical href=/hugo-template/post/2022-09-11-ambient-deep-dive-1/><link rel=stylesheet href=/hugo-template/css/bootstrap.min.css><link rel=stylesheet href=/hugo-template/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/hugo-template/css/zanshang.css><link rel=stylesheet href=/hugo-template/css/font-awesome.all.min.css><script src=/hugo-template/js/jquery.min.js></script><script src=/hugo-template/js/bootstrap.min.js></script><script src=/hugo-template/js/hux-blog.min.js></script><script src=/hugo-template/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Huabing Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/hugo-template/categories/books/>books</a></li><li><a href=/hugo-template/categories/open-source/>open source</a></li><li><a href=/hugo-template/categories/presentations/>presentations</a></li><li><a href=/hugo-template/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/hugo-template/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.unsplash.com/photo-1484976063837-eab657a7aca7?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1740&q=80)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/istio title=Istio>Istio
</a><a class=tag href=/tags/envoy title=Envoy>Envoy
</a><a class=tag href=/tags/service-mesh title="Service Mesh">Service Mesh
</a><a class=tag href=/tags/ambient-mesh title="Ambient Mesh">Ambient Mesh</a></div><h1>Istio Ambient 模式流量管理实现机制详解（一）</h1><h2 class=subheading>HBONE 隧道原理</h2><span class=meta>Posted by
赵化冰
on
Wednesday, September 28, 2022</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>Istio ambient 模式采用了被称为 <a href=https://www.zhaohuabing.com/post/2022-09-08-introducing-ambient-mesh/#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA-ambient-mesh>HBONE</a> 的方式来连接 ztunnel 和 waypoint proxy。HBONE 是 HTTP-Based Overlay Network Environment 的缩写。虽然该名称是第一次看到，其实 HBONE 并不是 Istio 创建出来的一个新协议，而只是利用了 HTTP 协议标准提供的隧道能力。简单地说，ambient 模式采用了 <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT>HTTP 的 CONNECT 方法</a> 在 ztunnel 和 waypoint proxy 创建了一个隧道，通过该隧道来传输数据。本文将分析 HBONE 的实现机制和原理。</p><h1 id=http-隧道原理>HTTP 隧道原理</h1><p>建立 HTTP 隧道的常见形式是采用 HTTP 协议的 CONNECT 方法。在这种机制下，客户端首先向 HTTP 代理服务器发送一个 HTTP CONNECT 请求，请求中携带需要连接的目的服务器。代理服务器根据该请求代表客户端连接目的服务器。和目的服务器建立连接后，代理服务器将客户端 TCP 数据流直接透明地传送给目的服务器。在这种方式中，只有初始连接请求是 HTTP，之后代理服务器处理的是 TCP 数据流。</p><p><img src=https://zhaohuabing.com/static/img/2022-09-11-ambient-hbone/http-tunnel.png alt></p><p>通过这种方法，我们可以采用 HTTP CONNECT 创建一个隧道，该隧道中可以传输任何类型的 TCP 数据。</p><p>例如在一个内网环境中，我们只允许通过 HTTP 代理来访问外部的 web 服务器。但我们可以通过 HTTP 隧道的方式来连接到一个外部的 SSH 服务器上。。</p><p>客户端连接到代理服务器，发送 HTTP CONNECT 请求通过和指定主机的 22 端口建立隧道。</p><pre tabindex=0><code>CONNECT for.bar.com:22 HTTP/1.1
</code></pre><p>如果代理允许连接，并且代理已连接到指定的主机，则代理将返回2XX成功响应。</p><pre tabindex=0><code>HTTP/1.1 200 OK
</code></pre><p>现在客户端将通过代理访问远程主机。 发送到代理服务器的所有数据都将原封不动地转发到远程主机。</p><p>客户端和服务器开始 SSH 通信。</p><pre tabindex=0><code>SSH-2.0-OpenSSH_4.3\r\n
... ggg
</code></pre><blockquote><p>备注：除了 HTTP CONNECT 以外，采用 HTTP GET 和 POST 也可以创建 HTTP 隧道，这种方式创建的隧道的原理是将 TCP 数据封装到 HTTP 数据包中发送到外部服务器，该外部服务器会提取并执行客户端的原始网络请求。外部服务器收到此请求的响应后，将其重新打包为HTTP响应，并发送回客户端。在这种方式中，客户端所有流量都封装在 HTTP GET 或者 POST 请求中。</p></blockquote><h1 id=envoy-的-internal-listener-机制>Envoy 的 Internal Listener 机制</h1><p>我们知道，<a href=https://man7.org/linux/man-pages/man2/socket.2.html>socket</a> 在操作系统内核接收网络数据，但 Envoy 还支持一种“用户空间 socket”。<a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/other_features/internal_listener>Internal Listener</a> 就用于从该“用户空间 socket”接收数据包。</p><p>Internal Listener 需要和一个 Cluster 一起使用，配置在 Cluster 中作为接收流量的 endpoint。如下所示：</p><p>定义一个 Internal Listener：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>name</span>: demo_internal_listener
</span></span><span style=display:flex><span><span style=color:#ff79c6>internal_listener</span>: {}
</span></span><span style=display:flex><span><span style=color:#ff79c6>filter_chains</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>filters</span>: [
</span></span><span style=display:flex><span>  ......
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>然后采用一个 Cluster 来连接 Egress Listener 和 Internal Listener。如下面的配置片段所示，该 Cluster 配置在 Egress Listener 的 HCM 中，其 endpoint 中的地址是一个 <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#envoy-v3-api-msg-config-core-v3-envoyinternaladdress>Envoy Internal Address</a>，表示 endpoint 对应的是一个 internal listener，而不是一个真正的 upstream host。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>name</span>: encap_cluster
</span></span><span style=display:flex><span><span style=color:#ff79c6>load_assignment</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>cluster_name</span>: encap_cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>lb_endpoints</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>envoy_internal_address</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>server_listener_name</span>: demo_internal_listener
</span></span></code></pre></div><p>通过这种方式， 可以将两个 Listener 串联起来，第一个 Listener 从操作系统内核接收网络数据，然后再经过 interal_listener_cluster 传递给 demo_internal_listener 处理，如下面的配置所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>name</span>: ingress
</span></span><span style=display:flex><span><span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>address</span>: <span style=color:#bd93f9>127.0.0.1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>9999</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>filter_chains</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>filters</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: tcp
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>stat_prefix</span>: ingress
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>cluster</span>: encap_cluster
</span></span></code></pre></div><p>为什么需要 Internal Listener？<a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/other_features/internal_listener#encapsulate-http-get-requests-in-a-http-connect-request>Envoy 的 HCM 不支持直接将 downstream 的 HTTP 请求通过 HTTP CONNECT 隧道转发给 upstream</a>，因此需要将从 egress listener 中收到的请求经过 HCM 处理后再转发给 Internal Listner 中的 TcpProxy，由该 TcpProxy 来和 upstream host 创建 HTTP 隧道。</p><h1 id=envoy-的-http-tunnel>Envoy 的 HTTP Tunnel</h1><p>我们可以采用 Envoy 来作为客户端创建一个到 HTTP Proxy 的 HTTP Tunnel，也可以采用 Envoy 来作为 HTTP Proxy 服务器接收来自客户端的 HTTP CONNECT 请求。</p><h2 id=envoy-作为-http-隧道客户端>Envoy 作为 HTTP 隧道客户端</h2><p>通过串联两个 Listener，可以将外部 Listener 中收到的 HTTP 请求通过 Internal Listener 创建的 HTTP 隧道发送到后端的代理服务器，如下所示（该配置文件来自 <a href=https://github.com/envoyproxy/envoy/blob/8537d2a29265e61aaa0349311e6fc5d592659b08/configs/encapsulate_http_in_http2_connect.yaml>Envoy Github 中的示例文件</a>）：</p><p>Egress（入口） Listener，从端口 1000 接收来自客户端的 HTTP 请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>name</span>: http
</span></span><span style=display:flex><span><span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>address</span>: <span style=color:#bd93f9>127.0.0.1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>10000</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>filter_chains</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>filters</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: envoy.filters.network.http_connection_manager
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>stat_prefix</span>: ingress_http
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>route_config</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>name</span>: local_route
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>virtual_hosts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>name</span>: local_service
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>domains</span>: [<span style=color:#f1fa8c>&#34;*&#34;</span>]
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>routes</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ff79c6>match</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>prefix</span>: <span style=color:#f1fa8c>&#34;/&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>cluster</span>: encap_cluster
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>http_filters</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff79c6>name</span>: envoy.filters.http.router
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
</span></span></code></pre></div><p>Internal Listener，其 filter chain 中配置的是一个 TcpProxy。该 TcpProxy 中设置了 <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto#envoy-v3-api-msg-extensions-filters-network-tcp-proxy-v3-tcpproxy-tunnelingconfig>tunneling_config</a> 选项，表示该 TcpProxy 将同 upstream 建立一个 HTTP 隧道，将收到的 TCP 数据通过该 HTTP 隧道发送到 upstream。Envoy 支持采用 HTTP/1.1 和 HTTP/2 两种方式创建隧道，具体采用哪种协议取决于 upstream cluster 配置中的 typed_extension_protocol_options 部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>name</span>: encap
</span></span><span style=display:flex><span><span style=color:#ff79c6>internal_listener</span>: {}
</span></span><span style=display:flex><span><span style=color:#ff79c6>filter_chains</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>filters</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: tcp
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>stat_prefix</span>: tcp_stats
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>cluster</span>: cluster_0
</span></span><span style=display:flex><span>      <span style=color:#6272a4># 表示该 TcpProxy 将采用 HTTP 隧道的方式代理数据</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>tunneling_config</span>: 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>hostname</span>: host.com:443
</span></span></code></pre></div><p>该 Cluster 配置在 Egress Cluster 的 HCM 中，用于关联 Egress Listener 和 Internal Listener。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>clusters</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>name</span>: encap_cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>load_assignment</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>cluster_name</span>: encap_cluster
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>lb_endpoints</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>envoy_internal_address</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>server_listener_name</span>: encap
</span></span></code></pre></div><p>该 Cluster 配置在 Internal Cluster 中，是 HTTP 隧道连接的 Upstream。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: cluster_0
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 该选项表示将采用 HTTP2 CONNECT 来创建隧道</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>typed_extension_protocol_options</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>envoy.extensions.upstreams.http.v3.HttpProtocolOptions</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>explicit_http_config</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>http2_protocol_options</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>load_assignment</span>:
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 隧道连接的 upstream server 地址</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>cluster_name</span>: cluster_0
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff79c6>lb_endpoints</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>: <span style=color:#bd93f9>127.0.0.1</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>10001</span>
</span></span></code></pre></div><p><img src=https://zhaohuabing.com/static/img/2022-09-11-ambient-hbone/envoy-http-tunnel-client.png alt></p><p>上面的示例中 Egress Listener 的 filter chain 中配置的是 HCM。由于 HTTP 隧道是透明传输 TCP 数据流的，因此其中可以是任意七层协议的数据，Egress Listener 中的 filter chain 中也可以配置为 Tcp Proxy。</p><h2 id=envoy-作为-http-隧道服务器>Envoy 作为 HTTP 隧道服务器</h2><p>当然，我们可以采用 Envoy 来作为 HTTP Proxy 来接收 HTTP CONNECT 请求，建立和客户端的 HTTP 隧道。Envoy 不能在同一个 Listener 里面建立隧道并将从 HTTP 数据从隧道中解封出来。要实现这一点，我们需要两层 listener，第一层 listener 中的 HCM 负责创建 HTTP CONNECT 隧道并从隧道中拿到 TCP 数据流，然后将该 TCP 数据流交给个 listener 中的 HCM 进行 HTTP 处理。</p><p>下面的配置将 Envoy 作为一个 HTTP CONNECT 隧道服务器端，并采用一个 Internal Listen 对隧道中的数据进行 HTTP 处理。（该配置文件来自 <a href=https://github.com/envoyproxy/envoy/blob/8537d2a29265e61aaa0349311e6fc5d592659b08/configs/terminate_http_in_http2_connect.yaml>Envoy Github 中的示例文件</a>）</p><p>Egress Listener，从 10001 端口接收来自隧道客户端的 HTTP CONNECT 请求，并将隧道中的数据递交给 Internal Listener 进行下一步处理。注意其中 HCM 的 <code>upgrade_type: CONNECT</code> 选项表示支持 HTTP CONNECT 隧道，<code>http2_protocol_options</code> 表示采用 HTTP/2。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>listeners</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>name</span>: listener_0
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>address</span>: <span style=color:#bd93f9>127.0.0.1</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>10001</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>filter_chains</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>filters</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>name</span>: envoy.filters.network.http_connection_manager
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>stat_prefix</span>: ingress_http
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>route_config</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>name</span>: local_route
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>virtual_hosts</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ff79c6>name</span>: local_service
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>domains</span>:
</span></span><span style=display:flex><span>            - <span style=color:#f1fa8c>&#34;*&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>routes</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>match</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>connect_matcher</span>:
</span></span><span style=display:flex><span>                  {}
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># 数据将被发送给 decap_cluster</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>cluster</span>: decap_cluster
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>upgrade_configs</span>:
</span></span><span style=display:flex><span>                - <span style=color:#ff79c6>upgrade_type</span>: CONNECT
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>connect_config</span>:
</span></span><span style=display:flex><span>                    {}
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>http_filters</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>name</span>: envoy.filters.http.router
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>http2_protocol_options</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>allow_connect</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>upgrade_configs</span>:
</span></span><span style=display:flex><span>        <span style=color:#6272a4># 该选项标准支持采用 HTTP CONNECT 请求来创建隧道</span>
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>upgrade_type</span>: CONNECT
</span></span></code></pre></div><p>Internal Listener，从隧道中拿到的 TCP 流解析出 HTTP 请求，并返回一个 HTTP 200 响应。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: decap
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>internal_listener</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>filter_chains</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>filters</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff79c6>name</span>: envoy.filters.network.http_connection_manager
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>stat_prefix</span>: ingress_http
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>route_config</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>name</span>: local_route
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>virtual_hosts</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>name</span>: local_service
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>domains</span>: [<span style=color:#f1fa8c>&#34;*&#34;</span>]
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>routes</span>:
</span></span><span style=display:flex><span>              - <span style=color:#ff79c6>match</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>prefix</span>: <span style=color:#f1fa8c>&#34;/&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>direct_response</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>status</span>: <span style=color:#bd93f9>200</span>
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>body</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>inline_string</span>: <span style=color:#f1fa8c>&#34;Hello, world!\n&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>http_filters</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ff79c6>name</span>: envoy.filters.http.router
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
</span></span></code></pre></div><p>采用一个 Cluster 来连接 Egress Listener 和 Internal Listener。该 Cluster 配置在 Egress Listener 的 HCM 中，其 endpoint 是 Internal Listener 的 name。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  <span style=color:#ff79c6>clusters</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: decap_cluster
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>load_assignment</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>cluster_name</span>: decap_cluster
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ff79c6>lb_endpoints</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>envoy_internal_address</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>server_listener_name</span>: decap
</span></span></code></pre></div><p><img src=https://zhaohuabing.com/static/img/2022-09-11-ambient-hbone/envoy-http-tunnel-server.png alt></p><h1 id=采用-envoy-来创建一个端到端的-http-connect-隧道>采用 Envoy 来创建一个端到端的 HTTP CONNECT 隧道</h1><p>从上面的分析可以得知，Envoy 可以作为 Tunnel Client 发起一个 HTTP CONNECT 隧道创建请求，也可以作为 Tunnel Server 来创建一个 HTTP CONNECT 隧道。因此我们可以采用两个 Envoy 来作为 HTTP CONNECT 隧道的两端，如下图所示：
<img src=https://zhaohuabing.com/static/img/2022-09-11-ambient-hbone/envoy-http-tunnel.png alt></p><h1 id=istio-的-hbone-隧道>Istio 的 HBONE 隧道</h1><p>Istio HBONE 采用了上面介绍的方法来创建 HTTP CONNET 隧道，TCP 流量在进入隧道时会进行 mTLS 加密，在出隧道时进行 mTLS 卸载。一个采用 HBONE 创建的连接如下所示：
<img src=https://zhaohuabing.com/static/img/2022-09-11-ambient-hbone/hbone-connection.png alt></p><p>HBONE 由于采用了 HTTP CONNECT 创建隧道，还可以在 HTTP CONNECT 请求中加入一些 header 来很方便地在 downstream 和 upstream 之间传递上下文信息，包括：</p><ul><li>authority - 请求的原始目的地址，例如 1.2.3.4:80。</li><li>X-Forwarded-For（可选） - 请求的原始源地址，用于在多跳访问之间保留源地址。</li><li>baggage (可选) - client/server 的一些元数据，在 telemetry 中使用。</li></ul><h1 id=小结>小结</h1><p>在这篇文章中，我们介绍了 Istio ambient 模式用来连接 ztunnel 和 waypoint proxy 的 HBONE 隧道的基本原理。下一篇文章中，我们将以 bookinfo demo 程序为例来深入分析 ambient 模式中的流量劫持原理。</p><h1 id=参考资料>参考资料</h1><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT>https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT</a></li><li><a href=https://zh.wikipedia.org/wiki/HTTP%E9%9A%A7%E9%81%93>https://zh.wikipedia.org/wiki/HTTP%E9%9A%A7%E9%81%93</a></li><li><a href=https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/upgrades>https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/upgrades</a></li><li><a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/other_features/internal_listener>https://www.envoyproxy.io/docs/envoy/latest/configuration/other_features/internal_listener</a></li><li><a href=https://docs.google.com/document/d/1Ofqtxqzk-c_wn0EgAXjaJXDHB9KhDuLe-W3YGG67Y8g>https://docs.google.com/document/d/1Ofqtxqzk-c_wn0EgAXjaJXDHB9KhDuLe-W3YGG67Y8g</a></li><li><a href=https://docs.google.com/document/d/1ubUG78rNQbwwkqpvYcr7KgM14kEHwitSsuorCZjR6qY/edit#>https://docs.google.com/document/d/1ubUG78rNQbwwkqpvYcr7KgM14kEHwitSsuorCZjR6qY/edit#</a></li></ul><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://lopins.github.io/hugo-template/><img src=/hugo-template/img/favicon.png>Huabing Blog</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/hugo-template/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/hugo-template/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/hugo-template/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/hugo-template/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/hugo-template/post/2022-09-26-servicemesh-summit2022-dubbo-aeraki-mesh/ data-toggle=tooltip data-placement=top title="Service Mesh Summit 2022 Dubbo Demo">&larr;
Previous Post</a></li><li class=next><a href=/hugo-template/post/2022-09-11-ambient-deep-dive-2/ data-toggle=tooltip data-placement=top title="Istio Ambient 模式流量管理实现机制详解（二）">Next
Post &rarr;</a></li></ul><link href=https://xxx.xxx.com/dist/Artalk.css rel=stylesheet><script src=https://xxx.xxx.com/dist/Artalk.js></script><div id=Comments></div><script>Artalk.init({el:"#Comments",pageKey:"https://lopins.github.io/hugo-template/post/2022-09-11-ambient-deep-dive-1/",pageTitle:"Istio Ambient 模式流量管理实现机制详解（一）",server:"https://xxx.xxx.com",site:"xxx blog"})</script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/aeraki title=aeraki>aeraki
</a><a href=/tags/aeraki-mesh title="aeraki mesh">aeraki mesh
</a><a href=/tags/ambient-mesh title="ambient mesh">ambient mesh
</a><a href=/tags/api-gateway title="api gateway">api gateway
</a><a href=/tags/bitcoin title=bitcoin>bitcoin
</a><a href=/tags/blockchain title=blockchain>blockchain
</a><a href=/tags/cka title=cka>cka
</a><a href=/tags/cncf title=cncf>cncf
</a><a href=/tags/cryptocurrency title=cryptocurrency>cryptocurrency
</a><a href=/tags/digital-signature title="digital signature">digital signature
</a><a href=/tags/docker title=docker>docker
</a><a href=/tags/dubbo title=dubbo>dubbo
</a><a href=/tags/envoy title=envoy>envoy
</a><a href=/tags/envoy-gateway title="envoy gateway">envoy gateway
</a><a href=/tags/ingress title=ingress>ingress
</a><a href=/tags/istio title=istio>istio
</a><a href=/tags/jaeger title=jaeger>jaeger
</a><a href=/tags/kafka title=kafka>kafka
</a><a href=/tags/knowledge-graph title="knowledge graph">knowledge graph
</a><a href=/tags/kubecon title=kubecon>kubecon
</a><a href=/tags/kubernetes title=kubernetes>kubernetes
</a><a href=/tags/linux title=linux>linux
</a><a href=/tags/loadbalancer title=loadbalancer>loadbalancer
</a><a href=/tags/metaprotocol title=metaprotocol>metaprotocol
</a><a href=/tags/microservice title=microservice>microservice
</a><a href=/tags/network title=network>network
</a><a href=/tags/network-service-mesh title="network service mesh">network service mesh
</a><a href=/tags/nfv title=nfv>nfv
</a><a href=/tags/nodeport title=nodeport>nodeport
</a><a href=/tags/onap title=onap>onap
</a><a href=/tags/opentracing title=opentracing>opentracing
</a><a href=/tags/pilot title=pilot>pilot
</a><a href=/tags/proxy-protocol title="proxy protocol">proxy protocol
</a><a href=/tags/redis title=redis>redis
</a><a href=/tags/sdn title=sdn>sdn
</a><a href=/tags/security title=security>security
</a><a href=/tags/service-mesh title="service mesh">service mesh
</a><a href=/tags/tencent title=tencent>tencent
</a><a href=/tags/x-forwarded-for title=x-forwarded-for>x-forwarded-for</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:youremail@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/hugo-template/your%20wechat%20qr%20code%20image><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/yourgithub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/yourlinkedinid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/yourstackoverflowid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Huabing Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Huabing Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/hugo-template/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>