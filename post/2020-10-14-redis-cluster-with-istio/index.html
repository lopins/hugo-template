<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Huabing Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://images.pexels.com/photos/358326/pexels-photo-358326.jpeg?cs=srgb&amp;dl=pexels-pixabay-358326.jpg&amp;fm=jpg"><meta property="twitter:image" content="https://images.pexels.com/photos/358326/pexels-photo-358326.jpeg?cs=srgb&amp;dl=pexels-pixabay-358326.jpg&amp;fm=jpg"><meta name=title content="在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像"><meta property="og:title" content="在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像"><meta property="twitter:title" content="在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像"><meta name=description content="Redis 是一个高性能的 key-value 存储系统，被广泛用于微服务架构中。本文将介绍如何通过 Istio 和 Envoy 实现客户端无感知的 Redis Cluster 数据分片，并实现读写分离、流量镜像等高级流量管理功能。"><meta property="og:description" content="Redis 是一个高性能的 key-value 存储系统，被广泛用于微服务架构中。本文将介绍如何通过 Istio 和 Envoy 实现客户端无感知的 Redis Cluster 数据分片，并实现读写分离、流量镜像等高级流量管理功能。"><meta property="twitter:description" content="Redis 是一个高性能的 key-value 存储系统，被广泛用于微服务架构中。本文将介绍如何通过 Istio 和 Envoy 实现客户端无感知的 Redis Cluster 数据分片，并实现读写分离、流量镜像等高级流量管理功能。"><meta property="twitter:card" content="summary"><meta name=keyword content="赵化冰, zhaohuabing, Zhaohuabing, , 赵化冰的网络日志, 赵化冰的博客, Zhaohuabing Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice"><link rel="shortcut icon" href=/hugo-template/img/favicon.ico><title>在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像 | 赵化冰的博客 | Zhaohuabing Blog</title>
<link rel=canonical href=/hugo-template/post/2020-10-14-redis-cluster-with-istio/><link rel=stylesheet href=/hugo-template/css/bootstrap.min.css><link rel=stylesheet href=/hugo-template/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/hugo-template/css/zanshang.css><link rel=stylesheet href=/hugo-template/css/font-awesome.all.min.css><script src=/hugo-template/js/jquery.min.js></script><script src=/hugo-template/js/bootstrap.min.js></script><script src=/hugo-template/js/hux-blog.min.js></script><script src=/hugo-template/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Huabing Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/hugo-template/categories/books/>books</a></li><li><a href=/hugo-template/categories/open-source/>open source</a></li><li><a href=/hugo-template/categories/presentations/>presentations</a></li><li><a href=/hugo-template/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/hugo-template/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.pexels.com/photos/358326/pexels-photo-358326.jpeg?cs=srgb&dl=pexels-pixabay-358326.jpg&fm=jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/istio title=Istio>Istio
</a><a class=tag href=/tags/envoy title=Envoy>Envoy
</a><a class=tag href=/tags/redis title=Redis>Redis</a></div><h1>在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像</h1><h2 class=subheading></h2><span class=meta>Posted by
    "赵化冰"
on
Tuesday, October 13, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>Redis 是一个高性能的 key-value 存储系统，被广泛用于微服务架构中。如果我们想要使用 Redis 集群模式提供的高级特性，则需要对客户端代码进行改动，这带来了应用升级和维护的一些困难。利用 Istio 和 Envoy ，我们可以在不修改客户端代码的前提下实现客户端无感知的 Redis Cluster 数据分片，并提供读写分离、流量镜像等高级流量管理功能。</p><h1 id=redis-cluster>Redis Cluster</h1><p>Redis 的一个常见用途是用作数据高速缓存。通过在应用服务器和数据库服务器之间加入一个 Redis 缓存层，可以减少应用服务器对数据库的大量读操作，避免数据库服务器在大压力下响应缓慢甚至宕机的风险，显著加强整个系统的健壮性。Redis 作为数据缓存的原理如图所示：</p><p><img src=https://zhaohuabing.com/static/img/2020-10-14-redis-cluster-with-istio/redis-as-cache.png alt></p><p>在一个小规模的系统中，上图所示的单个 Redis 就可以很好地实现缓存层的功能。当系统中需要缓存的数据量较大时，一个 Redis 服务器无法承担所有应用服务器的缓存需求；同时单个 Redis 实例失效时也会导致大量读请求被直接发送到后端的数据库服务器上，导致数据库服务器瞬时压力超标，影响系统的稳定性。我们可以采用 <a href=https://redis.io/topics/cluster-spec>Redis Cluster</a> 来对缓存数据进行分片，将不同的数据放到不同的 Redis 分片中，以提高 Redis 缓存层的容量能力。在每个 Redis 分片中，还可以采用多个 replica 节点对缓存的读请求进行负载分担，并实现 Redis 的高可用。采用了 Redis Cluster 的系统如下图所示：</p><p><img src=https://zhaohuabing.com/static/img/2020-10-14-redis-cluster-with-istio/redis-cluster-no-proxy.png alt></p><p>从图中可以看到，在 Redis Cluster 模式下，客户端需要根据集群的分片规则将不同 key 的读写操作发送到集群中不同的 Redis 节点上，因此客户端需要了解 Redis Cluster 的拓扑结构，这导致我们无法在不修改客户端的情况下将一个使用 Redis 独立节点模式的应用平滑迁移到 Redis Cluster 上。另外，由于客户端需要了解 Redis Cluster 的内部拓扑，也将导致客户端代码和 Redis Cluster 运维上的耦合，例如要实现读写分离或者流量镜像的话，就需要修改每个客户端的代码并重新部署。</p><p>这种场景下，我们可以在应用服务器和 Redis Cluster 之间放置一个 Envoy 代理服务器，由 Envoy 来负责将应用发出的缓存读写请求路由到正确的 Redis 节点上。一个微服务系统中存在大量需要访问缓存服务器的应用进程，为了避免单点故障和性能瓶颈，我们以 Sidecar 的形式为每个应用进程部署一个 Envoy 代理。同时，为了简化对这些代理的管理工作，我们可以采用 Istio 作为控制面来统一对所有 Envoy 代理进行配置,如下图所示：</p><p><img src=https://zhaohuabing.com/static/img/2020-10-14-redis-cluster-with-istio/redis-cluster-with-proxy.png alt></p><p>在本文的后续部分，我们将介绍如何通过 Istio 和 Envoy 来管理 Redis Cluster，实现客户端无感知的数据分区，以及读写分离、流量镜像等高级路由策略。</p><h1 id=部署-istio>部署 Istio</h1><p>Pilot 中已经支持了 Redis 协议，但功能较弱，只能为 Redis 代理配置一个缺省路由，而且不支持 Redis Cluster 模式，无法实现 Redis filter 的数据分片、读写分离、流量镜像等高级流量管理功能。为了让 Istio 可以将 Redis Cluster 相关的配置下发到 Envoy Sidecar 上，我们修改了 EnvoyFilter 配置相关代码，以支持 EnvoyFilter 的 &ldquo;REPLCAE&rdquo; 操作。该修改的 PR <a href=https://github.com/istio/istio/pull/27426/>Implement REPLACE operation for EnvoyFilter patch</a> 已经提交到 Istio 社区，并合入到了主分支中，将在 Istio 后续的版本中发布。</p><p>在撰写本文的时候，最新的 Istio 发布版本 1.7.3 中尚未合入该 PR。因此我构建了一个 Pilot 镜像，以启用 EnvoyFilter 的 &ldquo;REPLACE&rdquo; 操作。在安装 Istio 时，我们需要在 istioctl 命令中指定采用该 Pilot 镜像，如下面的命令行所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>cd</span> istio-1.7.3/bin
</span></span><span style=display:flex><span>$ ./istioctl install --set components.pilot.hub<span style=color:#ff79c6>=</span>zhaohuabing --set components.pilot.tag<span style=color:#ff79c6>=</span>1.7.3-enable-ef-replace
</span></span></code></pre></div><p>备注：如果你采用的 Istio 版本新于 1.7.3，并且已经合入了该 PR，则可以直接采用 Istio 版本中缺省的 Pilot 镜像。</p><h1 id=部署-redis-cluster>部署 Redis Cluster</h1><p>请从 <a href=https://github.com/zhaohuabing/istio-redis-culster>https://github.com/zhaohuabing/istio-redis-culster</a> 下载下面示例中需要用到的相关代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git clone https://github.com/zhaohuabing/istio-redis-culster.git
</span></span><span style=display:flex><span>$ <span style=color:#8be9fd;font-style:italic>cd</span> istio-redis-culster
</span></span></code></pre></div><p>我们创建一个 &ldquo;redis&rdquo; namespace 来部署本例中的 Redis Cluster。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create ns redis
</span></span><span style=display:flex><span>namespace/redis created
</span></span></code></pre></div><p>部署 Redis 服务器的 Statefulset 和 Configmap。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f k8s/redis-cluster.yaml -n redis
</span></span><span style=display:flex><span>configmap/redis-cluster created
</span></span><span style=display:flex><span>statefulset.apps/redis-cluster created
</span></span><span style=display:flex><span>service/redis-cluster created
</span></span></code></pre></div><h2 id=验证-redis-部署>验证 Redis 部署</h2><p>确认 Redis 节点已经启动并正常运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl get pod -n redis
</span></span><span style=display:flex><span>NAME              READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>redis-cluster-0   2/2     Running   <span style=color:#bd93f9>0</span>          4m25s
</span></span><span style=display:flex><span>redis-cluster-1   2/2     Running   <span style=color:#bd93f9>0</span>          3m56s
</span></span><span style=display:flex><span>redis-cluster-2   2/2     Running   <span style=color:#bd93f9>0</span>          3m28s
</span></span><span style=display:flex><span>redis-cluster-3   2/2     Running   <span style=color:#bd93f9>0</span>          2m58s
</span></span><span style=display:flex><span>redis-cluster-4   2/2     Running   <span style=color:#bd93f9>0</span>          2m27s
</span></span><span style=display:flex><span>redis-cluster-5   2/2     Running   <span style=color:#bd93f9>0</span>          117s
</span></span></code></pre></div><h2 id=创建-redis-cluster>创建 Redis Cluster</h2><p>在上面的步骤中，我们采用 Statefulset 部署了6个 Redis 节点，但目前这6个节点还是相互独立的，并未形成一个集群。下面我们采用 Redis 的 <code>cluster create</code> 命令将这些节点组成一个 Redis Cluster。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it redis-cluster-0 -n redis -- redis-cli --cluster create --cluster-replicas <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>$(</span>kubectl get pods -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-cluster -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;{range.items[*]}{.status.podIP}:6379 &#39;</span> -n redis<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>Defaulting container name to redis.
</span></span><span style=display:flex><span>Use <span style=color:#f1fa8c>&#39;kubectl describe pod/redis-cluster-0 -n redis&#39;</span> to see all of the containers in this pod.
</span></span><span style=display:flex><span>&gt;&gt;&gt; Performing <span style=color:#8be9fd;font-style:italic>hash</span> slots allocation on <span style=color:#bd93f9>6</span> nodes...
</span></span><span style=display:flex><span>Master<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]</span> -&gt; Slots <span style=color:#bd93f9>0</span> - <span style=color:#bd93f9>5460</span>
</span></span><span style=display:flex><span>Master<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span> -&gt; Slots <span style=color:#bd93f9>5461</span> - <span style=color:#bd93f9>10922</span>
</span></span><span style=display:flex><span>Master<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>]</span> -&gt; Slots <span style=color:#bd93f9>10923</span> - <span style=color:#bd93f9>16383</span>
</span></span><span style=display:flex><span>Adding replica 172.16.0.72:6379 to 172.16.0.138:6379
</span></span><span style=display:flex><span>Adding replica 172.16.0.201:6379 to 172.16.1.52:6379
</span></span><span style=display:flex><span>Adding replica 172.16.0.139:6379 to 172.16.1.53:6379
</span></span><span style=display:flex><span>M: 8fdc7aa28a6217b049a2265b87bff9723f202af0 172.16.0.138:6379
</span></span><span style=display:flex><span>   slots:<span style=color:#ff79c6>[</span>0-5460<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>5461</span> slots<span style=color:#ff79c6>)</span> master
</span></span><span style=display:flex><span>M: 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c 172.16.1.52:6379
</span></span><span style=display:flex><span>   slots:<span style=color:#ff79c6>[</span>5461-10922<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>5462</span> slots<span style=color:#ff79c6>)</span> master
</span></span><span style=display:flex><span>M: 0b86a0fbe76cdd4b48434b616b759936ca99d71c 172.16.1.53:6379
</span></span><span style=display:flex><span>   slots:<span style=color:#ff79c6>[</span>10923-16383<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>5461</span> slots<span style=color:#ff79c6>)</span> master
</span></span><span style=display:flex><span>S: 94b139d247e9274b553c82fbbc6897bfd6d7f693 172.16.0.139:6379
</span></span><span style=display:flex><span>   replicates 0b86a0fbe76cdd4b48434b616b759936ca99d71c
</span></span><span style=display:flex><span>S: e293d25881c3cf6db86034cd9c26a1af29bc585a 172.16.0.72:6379
</span></span><span style=display:flex><span>   replicates 8fdc7aa28a6217b049a2265b87bff9723f202af0
</span></span><span style=display:flex><span>S: ab897de0eca1376558e006c5b0a49f5004252eb6 172.16.0.201:6379
</span></span><span style=display:flex><span>   replicates 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c
</span></span><span style=display:flex><span>Can I <span style=color:#8be9fd;font-style:italic>set</span> the above configuration? <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>type</span> <span style=color:#f1fa8c>&#39;yes&#39;</span> to accept<span style=color:#ff79c6>)</span>: yes
</span></span><span style=display:flex><span>&gt;&gt;&gt; Nodes configuration updated
</span></span><span style=display:flex><span>&gt;&gt;&gt; Assign a different config epoch to each node
</span></span><span style=display:flex><span>&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
</span></span><span style=display:flex><span>Waiting <span style=color:#ff79c6>for</span> the cluster to join
</span></span><span style=display:flex><span>.
</span></span><span style=display:flex><span>&gt;&gt;&gt; Performing Cluster Check <span style=color:#ff79c6>(</span>using node 172.16.0.138:6379<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>M: 8fdc7aa28a6217b049a2265b87bff9723f202af0 172.16.0.138:6379
</span></span><span style=display:flex><span>   slots:<span style=color:#ff79c6>[</span>0-5460<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>5461</span> slots<span style=color:#ff79c6>)</span> master
</span></span><span style=display:flex><span>   <span style=color:#bd93f9>1</span> additional replica<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>M: 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c 172.16.1.52:6379
</span></span><span style=display:flex><span>   slots:<span style=color:#ff79c6>[</span>5461-10922<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>5462</span> slots<span style=color:#ff79c6>)</span> master
</span></span><span style=display:flex><span>   <span style=color:#bd93f9>1</span> additional replica<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>S: 94b139d247e9274b553c82fbbc6897bfd6d7f693 172.16.0.139:6379
</span></span><span style=display:flex><span>   slots: <span style=color:#ff79c6>(</span><span style=color:#bd93f9>0</span> slots<span style=color:#ff79c6>)</span> slave
</span></span><span style=display:flex><span>   replicates 0b86a0fbe76cdd4b48434b616b759936ca99d71c
</span></span><span style=display:flex><span>M: 0b86a0fbe76cdd4b48434b616b759936ca99d71c 172.16.1.53:6379
</span></span><span style=display:flex><span>   slots:<span style=color:#ff79c6>[</span>10923-16383<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>5461</span> slots<span style=color:#ff79c6>)</span> master
</span></span><span style=display:flex><span>   <span style=color:#bd93f9>1</span> additional replica<span style=color:#ff79c6>(</span>s<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>S: ab897de0eca1376558e006c5b0a49f5004252eb6 172.16.0.201:6379
</span></span><span style=display:flex><span>   slots: <span style=color:#ff79c6>(</span><span style=color:#bd93f9>0</span> slots<span style=color:#ff79c6>)</span> slave
</span></span><span style=display:flex><span>   replicates 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c
</span></span><span style=display:flex><span>S: e293d25881c3cf6db86034cd9c26a1af29bc585a 172.16.0.72:6379
</span></span><span style=display:flex><span>   slots: <span style=color:#ff79c6>(</span><span style=color:#bd93f9>0</span> slots<span style=color:#ff79c6>)</span> slave
</span></span><span style=display:flex><span>   replicates 8fdc7aa28a6217b049a2265b87bff9723f202af0
</span></span><span style=display:flex><span><span style=color:#ff79c6>[</span>OK<span style=color:#ff79c6>]</span> All nodes agree about slots configuration.
</span></span><span style=display:flex><span>&gt;&gt;&gt; Check <span style=color:#ff79c6>for</span> open slots...
</span></span><span style=display:flex><span>&gt;&gt;&gt; Check slots coverage...
</span></span><span style=display:flex><span><span style=color:#ff79c6>[</span>OK<span style=color:#ff79c6>]</span> All <span style=color:#bd93f9>16384</span> slots covered.
</span></span></code></pre></div><h2 id=验证-redis-cluster>验证 Redis Cluster</h2><p>我们可以采用 <code>cluster info</code> 命令查看 Redis Cluster 的配置信息和 Cluster 中的成员节点，以验证集群是否创建成功。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it redis-cluster-0 -c redis -n redis -- redis-cli cluster info 
</span></span><span style=display:flex><span>cluster_state:ok
</span></span><span style=display:flex><span>cluster_slots_assigned:16384
</span></span><span style=display:flex><span>cluster_slots_ok:16384
</span></span><span style=display:flex><span>cluster_slots_pfail:0
</span></span><span style=display:flex><span>cluster_slots_fail:0
</span></span><span style=display:flex><span>cluster_known_nodes:6
</span></span><span style=display:flex><span>cluster_size:3
</span></span><span style=display:flex><span>cluster_current_epoch:6
</span></span><span style=display:flex><span>cluster_my_epoch:1
</span></span><span style=display:flex><span>cluster_stats_messages_ping_sent:206
</span></span><span style=display:flex><span>cluster_stats_messages_pong_sent:210
</span></span><span style=display:flex><span>cluster_stats_messages_sent:416
</span></span><span style=display:flex><span>cluster_stats_messages_ping_received:205
</span></span><span style=display:flex><span>cluster_stats_messages_pong_received:206
</span></span><span style=display:flex><span>cluster_stats_messages_meet_received:5
</span></span><span style=display:flex><span>cluster_stats_messages_received:416
</span></span></code></pre></div><h2 id=部署测试用客户端>部署测试用客户端</h2><p>我们部署一个客户端，以用于发送测试命令:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f k8s/redis-client.yaml -n redis
</span></span><span style=display:flex><span>deployment.apps/redis-client created
</span></span></code></pre></div><h1 id=通过-istio-下发-redis-cluster-相关的-envoy-配置>通过 Istio 下发 Redis Cluster 相关的 Envoy 配置</h1><p>在下面的步骤中，我们将通过 Istio 向 Envoy Sidecar 下发 Redis Cluster 相关配置，以在无需改动客户端的情况下启用 Redis Cluster 的高级功能，包括数据分片、读写分离和流量镜像。</p><h2 id=创建-envoy-redis-cluster>创建 Envoy Redis Cluster</h2><p>Envoy 提供了 &ldquo;envoy.clusters.redis&rdquo; 类型的 Envoy Cluster 来连接后端的 Redis Cluster，Envoy 会通过该 Cluster 获取后端 Redis Cluster 的拓扑结构，包括有多少个分片（shard），每个分片负责哪些 slot，以及分片中包含哪些节点，以将来自客户端的请求分发到正确的 Redis 节点上。</p><p>采用 EnvoyFilter 来创建所需的 Envoy Redis Cluster：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f istio/envoyfilter-custom-redis-cluster.yaml
</span></span><span style=display:flex><span>envoyfilter.networking.istio.io/custom-redis-cluster created
</span></span></code></pre></div><h2 id=创建-envoy-redis-proxy>创建 Envoy Redis Proxy</h2><p>Istio 缺省下发的 LDS 中配置的是 TCP proxy filter，我们需要将其替换为 Redis Proxy filter。</p><p>由于 1.7.3 中尚不支持 EnvoyFilter 的 &ldquo;REPLACE&rdquo; 操作，我们首先需要更新 EnvoyFilter 的 CRD 定义，然后才能创建该 EnvoyFilter：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f istio/envoyfilter-crd.yaml 
</span></span><span style=display:flex><span>customresourcedefinition.apiextensions.k8s.io/envoyfilters.networking.istio.io configured
</span></span></code></pre></div><p>采用 EnvoyFilter 来将 TCP proxy filter 替换为 Redis Proxy filter，以使 Envoy 可以代理来自客户端的 Redis 操作请求：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sed -i .bak <span style=color:#f1fa8c>&#34;s/\${REDIS_VIP}/`kubectl get svc redis-cluster -n redis -o=jsonpath=&#39;{.spec.clusterIP}&#39;`/&#34;</span> istio/envoyfilter-redis-proxy.yaml
</span></span><span style=display:flex><span>$ kubectl apply -f istio/envoyfilter-redis-proxy.yaml
</span></span><span style=display:flex><span>envoyfilter.networking.istio.io/add-redis-proxy created
</span></span></code></pre></div><h1 id=验证-redis-cluster-功能>验证 Redis Cluster 功能</h1><p>现在一切就绪，下面我们来验证 Redis Cluster 的各项功能。</p><h2 id=redis-数据分片>Redis 数据分片</h2><p>我们通过 Istio 将 EnvoyFilter 中定义的配置下发到 Envoy 后，Envoy 就能够自动发现后端 Redis Cluster 的拓扑结构，并根据客户端请求中的 key 将请求自动分发到 Redis Cluster 中正确的节点上。</p><p>根据前面创建 Redis Cluster 步骤中的命令行输出，我们可以看出该 Redis Cluster 的拓扑结构：Cluster 中有三个分片，每个分片中有一个 Master 节点，一个 Slave(Replica) 节点。客户端通过和其部署在同一个 Pod 中的 Envoy Proxy 访问 Redis Cluster，如下图所示：</p><p><img src=https://zhaohuabing.com/static/img/2020-10-14-redis-cluster-with-istio/redis-cluster.png alt></p><p>Redis Cluster 中各个分片的 Master 和 Slave 节点地址：</p><pre tabindex=0><code>Shard[0] Master[0]  redis-cluster-0 172.16.0.138:6379   replica  redis-cluster-4 172.16.0.72:6379  -&gt; Slots 0 - 5460 
Shard[1] Master[1]  redis-cluster-1 172.16.1.52:6379    replica  redis-cluster-5 172.16.0.201:6379 -&gt; Slots 5461 - 10922
Shard[2] Master[2]  redis-cluster-2 172.16.1.53:6379    replica  redis-cluster-3 172.16.0.139:6379 -&gt; Slots 10923 - 16383
</code></pre><p>备注：如果你在自己的 K8s cluster 中部署该示例，那么 Redis Cluster 中各个节点的 IP 地址和拓扑结构可能稍有不同，但基本结构应该是类似的。</p><p>我们尝试从客户端向 Rdeis Cluster 发送一些不同 key 的 <code>set</code> 请求:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> a a
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> b b
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> c c
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> d d
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> e e
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> f f
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> g g
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> h h
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>从客户端来看，所有的请求都成功了，我们可以使用 <code>scan</code> 命令在服务器端查看各个节点中的数据：</p><p>查看分片 Shard[0] 中的数据，master 节点是 redis-cluster-0 slave 节点是 redis-cluster-4。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-0 -c redis -n redis -- redis-cli --scan
</span></span><span style=display:flex><span>b
</span></span><span style=display:flex><span>f
</span></span><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-4 -c redis -n redis -- redis-cli --scan
</span></span><span style=display:flex><span>f
</span></span><span style=display:flex><span>b
</span></span></code></pre></div><p>查看分片 Shard[1] 中的数据，master 节点是 redis-cluster-1 slave 节点是 redis-cluster-5。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-1 -c redis -n redis -- redis-cli --scan
</span></span><span style=display:flex><span>c
</span></span><span style=display:flex><span>g
</span></span><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-5 -c redis -n redis -- redis-cli --scan
</span></span><span style=display:flex><span>g
</span></span><span style=display:flex><span>c
</span></span></code></pre></div><p>查看分片 Shard[2] 中的数据，master 节点是 redis-cluster-2 slave 节点是 redis-cluster-3。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-2 -c redis -n redis -- redis-cli --scan
</span></span><span style=display:flex><span>a
</span></span><span style=display:flex><span>e
</span></span><span style=display:flex><span>d
</span></span><span style=display:flex><span>h
</span></span><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-3 -c redis -n redis -- redis-cli --scan
</span></span><span style=display:flex><span>h
</span></span><span style=display:flex><span>e
</span></span><span style=display:flex><span>d
</span></span><span style=display:flex><span>a
</span></span></code></pre></div><p>从上面的验证结果中可以看到，客户端设置的数据被分发到了 Redis Cluster 中的三个分片中。该数据分发过程是由 Envoy Redis Proxy 自动实现的，客户端并不感知后端的 Redis Cluster，对客户端而言，和该 Redis Cluster 的交互与和一个单一 Redis 节点的交互是相同的。</p><p>采用该方法，我们可以在应用业务规模逐渐扩张，单一 Redis 节点压力过大时，将系统中的 Redis 从单节点无缝迁移到集群模式。在集群模式下，不同 key 的数据被缓存在不同的数据分片中，我们可以增加分片中 Replica 节点的数量来对一个分片进行扩容，也可以增加分片个数来对整个集群进行扩展，以应对由于业务不断扩展而增加的数据压力。由于 Envoy 可以感知 Redis Cluster 集群拓扑，数据的分发由 Envoy 完成，整个迁移和扩容过程无需客户端，不会影响到线上业务的正常运行。</p><h2 id=redis-读写分离>Redis 读写分离</h2><p>在一个 Redis 分片中，通常有一个 Master 节点，一到多个 Slave（Replica）节点，Master 节点负责写操作，并将数据变化同步到 Slave 节点。当来自应用的读操作压力较大时，我们可以在分片中增加更多的 Replica，以对读操作进行负载分担。Envoy Redis Rroxy 支持设置不同的读策略：</p><ul><li><strong>MASTER：</strong> 只从 Master 节点读取数据，当客户端要求数据强一致性时需要采用该模式。该模式对 Master 压力较大，在同一个分片内无法采用多个节点对读操作进行负载分担。</li><li><strong>PREFER_MASTER：</strong> 优先从 Master 节点读取数据，当 Master 节点不可用时，从 Replica 节点读取。</li><li><strong>REPLICA：</strong> 只从 Replica 节点读取数据，由于 Master 到 Replica 的数据复制过程是异步执行的，采用该方式有可能读取到过期的数据，因此适用于客户端对数据一致性要求不高的场景。该模式下可以采用多个 Replica 节点来分担来自客户端的读负载。</li><li><strong>PREFER_REPLICA：</strong> 优先从 Replica 节点读取数据，当 Replica 节点不可用时，从 Master 节点读取。</li><li><strong>ANY：</strong> 从任意节点读取数据。</li></ul><p>在前面下发的 EnvoyFilter 中，我们将 Envoy Redis Proxy 的读策略设置为了 &ldquo;REPLICA&rdquo;， 因此客户端的读操作应该只会被发送到 Replica 节点。让我们使用下面的命令来验证读写分离的策略:</p><p>通过客户端发起一系列 key 为 &ldquo;b&rdquo; 的 <code>get</code> 和 <code>set</code> 操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;b&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;b&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;b&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> b bb
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;bb&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; 
</span></span></code></pre></div><p>在前面的 Redis Cluster 拓扑中，我们已经得知 key &ldquo;b&rdquo; 属于 Shard[0] 这个分片。我们可以通过命令 <code>redis-cli monitor</code> 查看该分片中 Master 和 Replica 节点中收到的命令。</p><p>Master 节点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-0 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>Slave 节点:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-4 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>从下图中可以看到，所有 <code>get</code> 请求都被 Envoy 发送到了 Replica 节点上。
<img src=https://zhaohuabing.com/static/img/2020-10-14-redis-cluster-with-istio/redis-cluster-read-policy.png alt></p><h2 id=redis-流量镜像>Redis 流量镜像</h2><p>Envoy Redis Proxy 支持流量镜像，即将客户端发送的请求同时发送到一个镜像 Redis 服务器/集群上。流量镜像是一个非常有用的功能，我们可以使用流量镜像将生产环境中的线上数据导入到测试环境中，以使用线上数据对应用进行尽可能真实的模拟测试，同时又不会影响到线上用户的正常使用。</p><p>我们创建一个单节点的 Redis 节点，用做镜像服务器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f k8s/redis-mirror.yaml -n redis 
</span></span><span style=display:flex><span>deployment.apps/redis-mirror created
</span></span><span style=display:flex><span>service/redis-mirror created
</span></span></code></pre></div><p>采用 EnvoFilter 来启用镜像策略：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sed -i .bak <span style=color:#f1fa8c>&#34;s/\${REDIS_VIP}/`kubectl get svc redis-cluster -n redis -o=jsonpath=&#39;{.spec.clusterIP}&#39;`/&#34;</span> istio/envoyfilter-redis-proxy-with-mirror.yaml
</span></span><span style=display:flex><span>$ kubectl apply -f istio/envoyfilter-redis-proxy-with-mirror.yaml
</span></span><span style=display:flex><span>envoyfilter.networking.istio.io/add-redis-proxy configured
</span></span></code></pre></div><p>通过客户端发起一系列 key 为 &ldquo;b&rdquo; 的 <code>get</code> 和 <code>set</code> 操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;b&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;b&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;b&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> b bb
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;bb&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> b bbb
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;bbb&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get b
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;bbb&#34;</span>
</span></span></code></pre></div><p>可以通过命令 <code>redis-cli monitor</code> 分别查看 Master、Replica 和镜像节点中收到的命令。</p><p>Master 节点:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-0 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>Slave 节点:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> redis-cluster-4 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>镜像节点:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-mirror -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-mirror -n redis -- redis-cli monitor
</span></span></code></pre></div><p>从下图中可以看到，所有 <code>set</code> 请求都被 Envoy 发送到了一份镜像节点上。
<img src=https://zhaohuabing.com/static/img/2020-10-14-redis-cluster-with-istio/redis-cluster-mirror-policy.png alt></p><h1 id=实现原理>实现原理</h1><p>在上面的步骤中，我们在 Istio 中创建了两个 EnvoyFilter 配置对象。这两个 EnvoyFilter 修改了 Envoy 代理的配置，主要包括两部分内容：Redis Proxy Network Filter 配置和 Redis Cluster 配置。</p><p>下面的 EnvoyFilter 替换了 Pilot 为 Redis Service 创建的 Listener 中的 TCP Proxy Network Filter，将其替换为一个 &ldquo;type.googleapis.com/envoy.config.filter.network.redis_proxy.v2.RedisProxy&rdquo; 类型的 Network Filter。 该 Redis Proxy 的缺省路由指向 &ldquo;custom-redis-cluster&rdquo;，并且配置了读写分离策略和流量镜像策略。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: networking.istio.io/v1alpha3
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: EnvoyFilter
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: add-redis-proxy
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: istio-system
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>configPatches</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>applyTo</span>: NETWORK_FILTER
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>match</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>listener</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>name</span>: ${REDIS_VIP}_6379             <span style=color:#6272a4># Replace REDIS_VIP with the cluster IP of &#34;redis-cluster service</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>filterChain</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>filter</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>name</span>: <span style=color:#f1fa8c>&#34;envoy.filters.network.tcp_proxy&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>patch</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>operation</span>: REPLACE
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>value</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>name</span>: envoy.redis_proxy
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/envoy.config.filter.network.redis_proxy.v2.RedisProxy
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>stat_prefix</span>: redis_stats
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>prefix_routes</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>catch_all_route</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>request_mirror_policy</span>:            <span style=color:#6272a4># Send requests to the mirror cluster</span>
</span></span><span style=display:flex><span>              - <span style=color:#ff79c6>cluster</span>: outbound|6379||redis-mirror.redis.svc.cluster.local
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>exclude_read_commands</span>: <span style=color:#ff79c6>True     # Mirror write commands only</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>cluster</span>: custom-redis-cluster
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>settings</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>op_timeout</span>: 5s
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>enable_redirection</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>enable_command_stats</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>read_policy</span>: REPLICA               <span style=color:#6272a4># Send read requests to replica</span>
</span></span></code></pre></div><p>下面的 EnvoyFilter 在 Pilot 下发的 CDS 中创建了一个 &ldquo;envoy.clusters.redis&rdquo; 类型的 Cluster： &ldquo;custom-redis-cluster&rdquo;，该 Cluster 会采用 <a href=https://redis.io/commands/cluster-slots>CLUSTER SLOTS 命令</a> 向 Redis 集群中的一个随机节点查询集群的拓扑结构，并在本地保存该拓扑结构，以将来自客户端的请求分发到集群中正确的 Redis 节点上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: networking.istio.io/v1alpha3
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: EnvoyFilter
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: custom-redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: istio-system
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>configPatches</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>applyTo</span>: CLUSTER
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>patch</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>operation</span>: INSERT_FIRST
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>value</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>name</span>: <span style=color:#f1fa8c>&#34;custom-redis-cluster&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>connect_timeout</span>: <span style=color:#bd93f9>0.</span>5s
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>lb_policy</span>: CLUSTER_PROVIDED
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>load_assignment</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>cluster_name</span>: custom-redis-cluster
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ff79c6>lb_endpoints</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>address</span>: redis-cluster-0.redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>address</span>: redis-cluster-1.redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>address</span>: redis-cluster-2.redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>address</span>: redis-cluster-3.redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>address</span>: redis-cluster-4.redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>            - <span style=color:#ff79c6>endpoint</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>address</span>:
</span></span><span style=display:flex><span>                  <span style=color:#ff79c6>socket_address</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>address</span>: redis-cluster-5.redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>port_value</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>cluster_type</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>name</span>: envoy.clusters.redis
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>typed_config</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;@type&#34;: </span>type.googleapis.com/google.protobuf.Struct
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>value</span>:
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>cluster_refresh_rate</span>: 5s
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>cluster_refresh_timeout</span>: 3s
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>redirect_refresh_interval</span>: 5s
</span></span><span style=display:flex><span>              <span style=color:#ff79c6>redirect_refresh_threshold</span>: <span style=color:#bd93f9>5</span>
</span></span></code></pre></div><h1 id=小结>小结</h1><p>本文介绍了如何使用 Envoy 为微服务应用提供客户端无感知的 Redis 数据分片，以及如何通过 Istio 来统一管理系统中多个 Envoy 代理的 Redis Cluster 配置。我们可以看到，采用 Istio 和 Envoy 可以大大简化客户端使用 Redis Cluster 的编码和配置工作，并且可以在线修改 Redis Cluster 的运维策略，实现读写分离、流量镜像等高级流量管理。当然，引入 Istio 和 Envoy 并未减少整个系统的复杂度，而是将 Redis Cluster 维护的工作从各个分散的应用代码中集中到了服务网格基础设施层。对应广大应用开放者来说，其业务价值主要来自于应用代码，将大量精力投入此类基础设施是不太划算的。建议直接采用腾讯云上的云原生 Service Mesh 服务 TCM（Tencent Cloud Mesh），为微服务应用快速引入 Service Mesh 的流量管理和服务治理能力，而无需再关注 Service Mesh 基础设施自身的安装、维护、升级等事项。</p><h1 id=参考文档>参考文档</h1><ul><li><a href=https://rancher.com/blog/2019/deploying-redis-cluster>https://rancher.com/blog/2019/deploying-redis-cluster</a></li><li><a href=https://medium.com/@fr33m0nk/migrating-to-redis-cluster-using-envoy-93a87ae79dc3>https://medium.com/@fr33m0nk/migrating-to-redis-cluster-using-envoy-93a87ae79dc3</a></li><li><a href=https://github.com/istio/istio/pull/27426/>Implement REPLACE operation for EnvoyFilter patch</a></li></ul><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://lopins.github.io/hugo-template/><img src=/hugo-template/img/favicon.png>Huabing Blog</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/hugo-template/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/hugo-template/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/hugo-template/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/hugo-template/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/hugo-template/post/2020-09-19-headless-mtls/ data-toggle=tooltip data-placement=top title="Istio 运维实战系列（3）：让人头大的『无头服务』-下">&larr;
Previous Post</a></li><li class=next><a href=/hugo-template/post/2020-11-12-cnbps2020/ data-toggle=tooltip data-placement=top title="CNBPS 2020：云原生应用架构专场介绍">Next
Post &rarr;</a></li></ul><link href=https://xxx.xxx.com/dist/Artalk.css rel=stylesheet><script src=https://xxx.xxx.com/dist/Artalk.js></script><div id=Comments></div><script>Artalk.init({el:"#Comments",pageKey:"https://lopins.github.io/hugo-template/post/2020-10-14-redis-cluster-with-istio/",pageTitle:"在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像",server:"https://xxx.xxx.com",site:"xxx blog"})</script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/aeraki title=aeraki>aeraki
</a><a href=/tags/aeraki-mesh title="aeraki mesh">aeraki mesh
</a><a href=/tags/ambient-mesh title="ambient mesh">ambient mesh
</a><a href=/tags/api-gateway title="api gateway">api gateway
</a><a href=/tags/bitcoin title=bitcoin>bitcoin
</a><a href=/tags/blockchain title=blockchain>blockchain
</a><a href=/tags/cka title=cka>cka
</a><a href=/tags/cncf title=cncf>cncf
</a><a href=/tags/cryptocurrency title=cryptocurrency>cryptocurrency
</a><a href=/tags/digital-signature title="digital signature">digital signature
</a><a href=/tags/docker title=docker>docker
</a><a href=/tags/dubbo title=dubbo>dubbo
</a><a href=/tags/envoy title=envoy>envoy
</a><a href=/tags/envoy-gateway title="envoy gateway">envoy gateway
</a><a href=/tags/ingress title=ingress>ingress
</a><a href=/tags/istio title=istio>istio
</a><a href=/tags/jaeger title=jaeger>jaeger
</a><a href=/tags/kafka title=kafka>kafka
</a><a href=/tags/knowledge-graph title="knowledge graph">knowledge graph
</a><a href=/tags/kubecon title=kubecon>kubecon
</a><a href=/tags/kubernetes title=kubernetes>kubernetes
</a><a href=/tags/linux title=linux>linux
</a><a href=/tags/loadbalancer title=loadbalancer>loadbalancer
</a><a href=/tags/metaprotocol title=metaprotocol>metaprotocol
</a><a href=/tags/microservice title=microservice>microservice
</a><a href=/tags/network title=network>network
</a><a href=/tags/network-service-mesh title="network service mesh">network service mesh
</a><a href=/tags/nfv title=nfv>nfv
</a><a href=/tags/nodeport title=nodeport>nodeport
</a><a href=/tags/onap title=onap>onap
</a><a href=/tags/opentracing title=opentracing>opentracing
</a><a href=/tags/pilot title=pilot>pilot
</a><a href=/tags/proxy-protocol title="proxy protocol">proxy protocol
</a><a href=/tags/redis title=redis>redis
</a><a href=/tags/sdn title=sdn>sdn
</a><a href=/tags/security title=security>security
</a><a href=/tags/service-mesh title="service mesh">service mesh
</a><a href=/tags/tencent title=tencent>tencent
</a><a href=/tags/x-forwarded-for title=x-forwarded-for>x-forwarded-for</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:youremail@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/hugo-template/your%20wechat%20qr%20code%20image><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/yourgithub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/yourlinkedinid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/yourstackoverflowid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Huabing Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Huabing Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/hugo-template/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>