<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Huabing Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://images.unsplash.com/photo-1473186578172-c141e6798cf4?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1973&amp;q=80"><meta property="twitter:image" content="https://images.unsplash.com/photo-1473186578172-c141e6798cf4?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1973&amp;q=80"><meta name=title content="Database Mesh: Simplify Redis Cluster with Istio and Aeraki"><meta property="og:title" content="Database Mesh: Simplify Redis Cluster with Istio and Aeraki"><meta property="twitter:title" content="Database Mesh: Simplify Redis Cluster with Istio and Aeraki"><meta name=description content="Managing a Redis Cluster can be complicated. With the help of Istio and Aeraki, advanced Redis features such as data sharding, prefix routing, read/write separation, traffic mirroring, fault injection can be easily achieved without modifying the applications."><meta property="og:description" content="Managing a Redis Cluster can be complicated. With the help of Istio and Aeraki, advanced Redis features such as data sharding, prefix routing, read/write separation, traffic mirroring, fault injection can be easily achieved without modifying the applications."><meta property="twitter:description" content="Managing a Redis Cluster can be complicated. With the help of Istio and Aeraki, advanced Redis features such as data sharding, prefix routing, read/write separation, traffic mirroring, fault injection can be easily achieved without modifying the applications."><meta property="twitter:card" content="summary"><meta name=keyword content="赵化冰, zhaohuabing, Zhaohuabing, , 赵化冰的网络日志, 赵化冰的博客, Zhaohuabing Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice"><link rel="shortcut icon" href=/hugo-template/img/favicon.ico><title>Database Mesh: Simplify Redis Cluster with Istio and Aeraki | 赵化冰的博客 | Zhaohuabing Blog</title>
<link rel=canonical href=/hugo-template/post/2023-05-08-manage-redis-with-aeraki-mes-eng/><link rel=stylesheet href=/hugo-template/css/bootstrap.min.css><link rel=stylesheet href=/hugo-template/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/hugo-template/css/zanshang.css><link rel=stylesheet href=/hugo-template/css/font-awesome.all.min.css><script src=/hugo-template/js/jquery.min.js></script><script src=/hugo-template/js/bootstrap.min.js></script><script src=/hugo-template/js/hux-blog.min.js></script><script src=/hugo-template/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Huabing Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/hugo-template/categories/books/>books</a></li><li><a href=/hugo-template/categories/open-source/>open source</a></li><li><a href=/hugo-template/categories/presentations/>presentations</a></li><li><a href=/hugo-template/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/hugo-template/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.unsplash.com/photo-1473186578172-c141e6798cf4?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1973&q=80)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/aeraki-mesh title="Aeraki Mesh">Aeraki Mesh
</a><a class=tag href=/tags/redis title=Redis>Redis</a></div><h1>Database Mesh: Simplify Redis Cluster with Istio and Aeraki</h1><h2 class=subheading></h2><span class=meta>Posted by
赵化冰
on
Tuesday, May 9, 2023</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>Redis is a high-performing key-value database known for its versatility in supporting a diverse range of data structures and operations, including strings, hashes, lists, sets, and sorted sets. Its robust capabilities make it an ideal choice for caching, session storage, message brokers, and other similar applications.</p><p><a href=https://istio.io/>Istio</a> is one of the most popular service mesh platforms that provides a unified way to connect, secure, and manage microservices. <a href=https://www.aeraki.net/>Aeraki Mesh</a> is a CNCF open-source project that works with Istio and enhances Istio’s capabilities by providing advanced traffic management for non-HTTP protocols including Thrift, Dubbo, Redis, and proprietary protocols.</p><p>Managing a Redis Cluster can be complicated. Istio and Aeraki can help with that. This post uses a demo to demonstrate how to use Istio and Aeraki to manage Redis traffic for your applications, providing client-transparent advanced features such as data sharding, prefix routing, read/write separation, traffic mirroring, fault injection, etc.</p><h2 id=system-architecture>System architecture</h2><p>Aeraki and Istio operate on the control plane, while the data plane is composed of Envoy sidecars. In the control plane, Aeraki provides two user-friendly Kubernetes Custom Resource Definitions (CRDs), <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a> and <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RedisDestination</a>, as the rules for users to manage Redis traffic. Aeraki converts these traffic rules into data plane configurations and deploys them to Envoy sidecars through xDS. Envoy sidecars work on the data plane, intercepting Redis client requests and providing relevant traffic management capabilities based on the configuration deployed from the control plane.
<img src=https://zhaohuabing.com/static/img/2023-05-08-manage-redis-with-aeraki-mesh/aeraki-redis.png alt></p><h2 id=install-the-demo>Install the demo</h2><p>First, download Aeraki Mesh from GitHub.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/aeraki-mesh/aeraki.git
</span></span></code></pre></div><p>Before installing Aeraki, it is necessary to first install Istio since Aeraki is built on top of Istio. However, the Aeraki installation script takes care of Istio installation automatically, so executing the Aeraki installation script is all that is required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>make demo
</span></span></code></pre></div><p>Execute the following script. This script creates a namespace called redis and deploy the Redis demo application within it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./demo/redis/install.sh
</span></span></code></pre></div><p>The demo application includes a 6-node Redis cluster (a Kubernetes StatefulSet), a single-mode Redis instance, and a Redis client. Later on, this demo will be used to demonstrate Aeraki Mesh’s traffic management capabilities for Redis.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n redis get pod
</span></span><span style=display:flex><span>NAME                            READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>redis-client-644c965f48-dvjc7   2/2     Running   <span style=color:#bd93f9>0</span>          2m17s
</span></span><span style=display:flex><span>redis-cluster-0                 1/1     Running   <span style=color:#bd93f9>0</span>          2m17s
</span></span><span style=display:flex><span>redis-cluster-1                 1/1     Running   <span style=color:#bd93f9>0</span>          2m15s
</span></span><span style=display:flex><span>redis-cluster-2                 1/1     Running   <span style=color:#bd93f9>0</span>          2m13s
</span></span><span style=display:flex><span>redis-cluster-3                 1/1     Running   <span style=color:#bd93f9>0</span>          2m12s
</span></span><span style=display:flex><span>redis-cluster-4                 1/1     Running   <span style=color:#bd93f9>0</span>          2m11s
</span></span><span style=display:flex><span>redis-cluster-5                 1/1     Running   <span style=color:#bd93f9>0</span>          2m10s
</span></span><span style=display:flex><span>redis-single-ccbb984dc-qz22v    1/1     Running   <span style=color:#bd93f9>0</span>          2m17s
</span></span></code></pre></div><h2 id=redis-server-authentication>Redis server authentication</h2><p>In the demo environment, the redis-single service has been configured with an access password. Attempting to access this service via a client will result in Redis prompting the user for authentication and denying the request.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>redis-single:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> a a
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> NOAUTH Authentication required.
</span></span></code></pre></div><p>Without Aeraki Mesh, the client needs to know whether authentication is required, as well as any necessary usernames and passwords for authentication. This adds complexity to client code.</p><p>By using Aeraki Mesh’s <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RedisDestination</a>, the password for accessing Redis can be set at the runtime, and authentication between the client and Redis server can be handled by the Sidecar Proxy. This eliminates the need for the Client to manage password information for the Redis service.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: v1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: Secret
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-service-secret
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>type</span>: Opaque
</span></span><span style=display:flex><span><span style=color:#ff79c6>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>password</span>: dGVzdHJlZGlzCg==
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisDestination
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-single
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>: redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>trafficPolicy</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>connectionPool</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>auth</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>secret</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>name</span>: redis-service-secret
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>With this Aeraki Redis traffic rule, you should be able to access the redis-single service without any issues.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><h2 id=client-side-authentication>Client-side authentication</h2><p>In some cases, you may want the access password used by the client to differ from the actual password for the Redis service. Doing so provides a number of advantages, including the ability to change the Redis service password without impacting the client and reducing the likelihood of exposing sensitive credentials. Through <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a>, clients can be assigned separate access passwords to meet these needs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-single
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>settings</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>auth</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>plain</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>password</span>: testredis123!
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>To access the redis-single service at this time, the new password set within the above RedisService must be used.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> ERR invalid password
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis123!
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-single:6379&gt; get foo
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;bar&#34;</span>
</span></span></code></pre></div><blockquote><p>Note: Both the RedisDestination and RedisService “auth” fields support two different methods for obtaining keys: “secret” and “plain”. “Secret” indicates that any necessary username and password information can be found inside a Kubernetes secret resource. In such cases, the default username value for “auth” will be the “username” defined within the specified secret, with either the “password” or “token” serving as the associated password for “auth”. However, if alternative fields within the secret are used for authentication purposes, the configuration of “passwordField” and “usernameField” can be used to specify which password and username fields should be utilized for authentication.</p></blockquote><h2 id=making-redis-deployment-mode-transparent-to-clients>Making Redis deployment mode transparent to clients</h2><p>Redis can be deployed in either single-node or cluster mode. Cluster mode offers several advantages over single-node mode, including:</p><ul><li>Supports horizontal scaling by increasing the number of nodes to improve performance and capacity.</li><li>Supports automatic partitioning to distribute data across different nodes, enhancing load balancing and availability.</li><li>Provides a certain degree of fault tolerance, enabling automatic failover and recovery even if a node fails or network issues arise.</li></ul><p>Redis requires different client APIs for accessing single-node and cluster modes. However, by leveraging Aeraki Mesh’s Redis traffic management features, you can easily switch between these two modes without needing to modify client code, thus simplifying application development.</p><p>As an example, you might use a small, single-instance Redis service for testing purposes, while deploying a Redis cluster consisting of multiple instances for production workloads. Through the use of Aeraki Mesh, you can seamlessly connect our application to these different Redis services without needing to adjust application code or configurations, <a href=https://12factor.net/dev-prod-parity>ensuring that development, staging, and production environments remain consistent throughout the software deployment cycle</a>.</p><p>The Redis cluster deployed in the demo consists of six instances divided into three shards, each with one master node and one slave node. You can view the topology of this Redis cluster using the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it redis-cluster-0 -c redis -n redis -- redis-cli cluster shards
</span></span></code></pre></div><p><img src=https://zhaohuabing.com/static/img/2023-05-08-manage-redis-with-aeraki-mesh/redis-cluster.png alt></p><p>The Redis cluster’s topology is depicted in the above diagram, which shows that the cluster consists of three shards, with each shard responsible for a specific range of slots. Shard 0 handles slots 0 through 5460, Shard 1 handles slots 5461 through 10922, and Shard 2 handles slots 10923 through 16383. Importantly, each key is associated with a specific slot number, which is calculated using the formula CRC16(key) mod 16384.</p><p>Therefore, when writing or reading data to the Redis cluster, clients must first calculate the slot number based on the CRC16(key) mod 16384 algorithm, and then send the request to the corresponding node in the appropriate shard.</p><p>If you attempt to access the Redis cluster in the demo, you may encounter the following access error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> foo bar
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> MOVED <span style=color:#bd93f9>15495</span> 10.244.0.23:6379
</span></span></code></pre></div><p>The reason for this error is that the Redis client is using a regular API, which means that requests are sent to the redis-cluster service and then forwarded to a random Redis node in the cluster. If that node is not responsible for handling the corresponding slot of the key in the request, the node will return a MOVED error indicating which node the client should connect to instead.</p><p>Unfortunately, since the client is using a regular API, it is unable to interpret this error and automatically resend the request to the appropriate node. As a result, the client continues to return an error.</p><p>By setting the mode parameter in <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisDestination>RdisDestination</a> to CLUSTER, Aeraki Mesh is able to abstract away the differences between Redis’ Cluster mode and standalone mode.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>
</span></span><span style=display:flex><span>```yaml
</span></span><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisDestination
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: external-redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>: external-redis.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>trafficPolicy</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>connectionPool</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>mode</span>: CLUSTER
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>Now, you can interact with the redis-cluster service just as you would with a standalone Redis node.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> foo bar
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>With this approach, you can seamlessly switch between development and production environments without modifying application code. Additionally, as our business grows and the demands on our Redis infrastructure become too burdensome, you can effortlessly migrate from a single-node Redis deployment to a Cluster.</p><p>In a Redis cluster, different keys are stored across different shards, allowing us to scale up by either increasing the number of replica nodes within each shard or adding additional shards to the cluster itself. This ensures that you can effectively manage any increases in data pressure that may result from ongoing business expansion. By integrating with Envoy proxy and leveraging its powerful traffic management functionality, Aeraki Mesh makes the entire migration and scaling process fully transparent, ensuring that online business operations remain uninterrupted throughout.</p><h2 id=prefix-routing>Prefix routing</h2><p>You can route traffic to different Redis services based on the prefix of the requested key with the help of RedisService.</p><p>As an example, consider the following <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a>, which routes any key beginning with “cluster” to the redis-cluster service, while all other keys are directed to the redis-single service.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>match</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>key</span>:
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>prefix</span>: cluster
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>With this configuration in place, first, you use a Redis client to access the redis-cluster service and set values for two distinct keys, “test-route” and “cluster-test-route”. You can then retrieve the values of these keys using the get command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> test-route <span style=color:#f1fa8c>&#34;this key goes to redis-single&#34;</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> cluster-test-route <span style=color:#f1fa8c>&#34;this key goes to redis-cluster&#34;</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get test-route
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to redis-single&#34;</span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get cluster-test-route
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to redis-cluster
</span></span></span></code></pre></div><p>If you connect to the redis-single service, you can see that it only contains the “test-route” key, while the value of the “cluster-test-route” key is nil. This behavior confirms our RedisService configuration, as it shows that “test-route” has been correctly routed to the redis-single service, while “cluster-test-route” is being handled by the redis-cluster service.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis123!
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-single:6379&gt; get test-route
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to redis-single&#34;</span>
</span></span><span style=display:flex><span>redis-single:6379&gt; get cluster-test-route
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>nil<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><h2 id=readwrite-separation>Read/write separation</h2><p>In Redis Cluster, there are multiple shards, each consisting of a master node and one or more replica(slave) nodes. The master nodes are responsible for handling write operations and synchronizing updates with their associated replicas. Replicas, in turn, serve as backup nodes and can respond to client read requests since they maintain an identical dataset to that of their master.</p><p>Aeraki Mesh supports setting different read policies for Redis through <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a>:</p><ul><li>MASTER: the default read mode. It only reads data from the master node and should be used when strong consistency is required. This mode places significant pressure on the master node and cannot distribute read workload among replicas within the same shard.</li><li>PREFER_MASTER: prioritizes reading data from the master node, but will fall back to replica nodes if it becomes unavailable.</li><li>REPLICA: only read data from the replica nodes. Since the replication process between master and replica is asynchronous, this mode may return outdated data and is therefore suitable for scenarios where clients do not require strict data consistency. Multiple replicas can effectively distribute read load in this mode.</li><li>PREFER_REPLICA: prioritize reading data from the replica nodes, but will revert to the master node if they become unavailable.</li><li>ANY: read data from any available node.</li></ul><p>By setting the read mode to REPLICA, you can reduce the workload on the master node by having it only handle write operations while the replica nodes handle read operations. As our business grows, you can also increase the number of replica nodes within a shard to distribute read operations across multiple nodes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>settings</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>readPolicy</span>: REPLICA  
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><h2 id=traffic-mirroring>Traffic mirroring</h2><p>Using <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a>, you have the ability to duplicate any requests sent to a Redis service and route them to another Redis service concurrently. The client will only receive the response from the primary Redis service, while the response from the mirrored Redis service is discarded. You can also set the percentage of traffic that is mirrored, for example, mirroring 50% of the traffic to another Redis service.</p><p>For example, consider the following RedisService configuration, which mirrors any requests sent to the redis-cluster service to the redis-single service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>mirror</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>host</span>: redis-single.redis.svc.cluster.local
</span></span><span style=display:flex><span>          <span style=color:#ff79c6>percentage</span>: 
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>value</span>: <span style=color:#bd93f9>100</span>
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>Apply the above configuration, then let’s connect to redis-cluster and set the value of <code>test-traffic-mirroring</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; <span style=color:#8be9fd;font-style:italic>set</span> test-traffic-mirroring <span style=color:#f1fa8c>&#34;this key goes to both redis-cluster and redis-single&#34;</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get test-traffic-mirroring
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to both redis-cluster and redis-single&#34;</span>
</span></span></code></pre></div><p>Now if you connect to redis-single, you can see that the key “test-traffic-mirroring” also exists in the redis-single service. This implies that the requests sent to the redis-cluster were mirrored to the redis-single.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-single
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-single:6379&gt; AUTH testredis123!
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>redis-single:6379&gt; get test-traffic-mirroring
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;this key goes to both redis-cluster and redis-single&#34;</span>
</span></span></code></pre></div><h2 id=fault-injection>Fault injection</h2><p>Using <a href=https://aeraki.net/zh/docs/v1.x/reference/redis/#RedisService>RedisService</a>, you can inject faults into Redis services, which can be useful for conducting chaos testing and other scenarios to ensure that the system properly handles Redis failures.</p><p>RedisService supports two types of fault configurations:</p><ul><li>Delay (DELAY): Adds delay to responses.</li><li>Error (ERROR): Returns errors on requests.</li></ul><p>For instance, the following configuration will result in 50% of GET commands directly returning errors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: redis.aeraki.io/v1alpha1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: RedisService
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: redis-cluster
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>host</span>:
</span></span><span style=display:flex><span>    - redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>redis</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>route</span>:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>host</span>: redis-cluster.redis.svc.cluster.local
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>faults</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>type</span>: ERROR
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>percentage</span>: 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>value</span>: <span style=color:#bd93f9>50</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>commands</span>:
</span></span><span style=display:flex><span>        - GET
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><p>Apply the above configuration, then connect to redis-cluster through the client, half of the GET commands will return the error message <code>Fault Injected: Error</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#8be9fd;font-style:italic>exec</span> -it <span style=color:#f1fa8c>`</span>kubectl get pod -l <span style=color:#8be9fd;font-style:italic>app</span><span style=color:#ff79c6>=</span>redis-client -n redis -o <span style=color:#8be9fd;font-style:italic>jsonpath</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;{.items[0].metadata.name}&#34;</span><span style=color:#f1fa8c>`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get a
</span></span><span style=display:flex><span><span style=color:#ff79c6>(</span>error<span style=color:#ff79c6>)</span> Fault Injected: Error
</span></span><span style=display:flex><span>redis-cluster:6379&gt; get a
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;a&#34;</span>
</span></span></code></pre></div><h2 id=connect-to-external-redis>Connect to external redis</h2><p>While the Redis service in the demo is deployed within a Kubernetes cluster, it’s possible to use Aeraki Mesh to connect to a Redis service that’s outside of the cluster. This can be done by creating a <a href=https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors>service without selectors</a>, followed by creating an EndpointSlice for the service to specify the address of the external Redis. Once that’s done, RedisService and Redis Destination can be used to manage traffic for the service, just as they would for Redis within the cluster.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f- &lt;&lt;EOF 
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: v1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: Service
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: external-redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ff79c6>name</span>: tcp-redis
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>targetPort</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: discovery.k8s.io/v1
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: EndpointSlice
</span></span><span style=display:flex><span><span style=color:#ff79c6>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: external-redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>namespace</span>: redis
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>kubernetes.io/service-name</span>: external-redis
</span></span><span style=display:flex><span><span style=color:#ff79c6>addressType</span>: IPv4
</span></span><span style=display:flex><span><span style=color:#ff79c6>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>name</span>: tcp-redis
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>port</span>: <span style=color:#bd93f9>6379</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>protocol</span>: TCP
</span></span><span style=display:flex><span><span style=color:#ff79c6>endpoints</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>addresses</span>:
</span></span><span style=display:flex><span>      - <span style=color:#bd93f9>10.244.0.26</span> <span style=color:#6272a4># 集群外 Redis 实例的地址，比如云厂商提供的 Redis 服务。</span>
</span></span><span style=display:flex><span>EOF
</span></span></code></pre></div><h1 id=wrapping-up>Wrapping up</h1><p>This article has demonstrated how to use Aeraki Mesh for traffic management on Redis, covering features such as authentication, redis cluster, prefix routing, traffic mirroring, and fault injection. These functions are now available in the latest version of Aeraki Mesh, and we encourage everyone to try them out and provide feedback and suggestions. For more information about Aeraki Mesh, please refer to its <a href=https://www.aeraki.net>official website</a> and <a href=http://github.com/aeraki-mesh>GitHub repository</a>.</p><h1 id=references>References</h1><ul><li>Aeraki Mesh: <a href=https://aeraki.net/>https://aeraki.net/</a></li><li>GitHub: <a href=https://github.com/aeraki-mesh>https://github.com/aeraki-mesh</a></li></ul><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://lopins.github.io/hugo-template/><img src=/hugo-template/img/favicon.png>Huabing Blog</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/hugo-template/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/hugo-template/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/hugo-template/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/hugo-template/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/hugo-template/post/2023-05-08-manage-redis-with-aeraki-mesh/ data-toggle=tooltip data-placement=top title="Database Mesh: 使用 Istio 和 Aeraki 对 Redis 进行流量管理">&larr;
Previous Post</a></li><li class=next><a href=/hugo-template/post/2023-06-24-aeraki-1.3.0/ data-toggle=tooltip data-placement=top title="Aeraki Mesh 发布 1.3.0 版本（代号：Dragonboat）">Next
Post &rarr;</a></li></ul><link href=https://xxx.xxx.com/dist/Artalk.css rel=stylesheet><script src=https://xxx.xxx.com/dist/Artalk.js></script><div id=Comments></div><script>Artalk.init({el:"#Comments",pageKey:"https://lopins.github.io/hugo-template/post/2023-05-08-manage-redis-with-aeraki-mes-eng/",pageTitle:"Database Mesh: Simplify Redis Cluster with Istio and Aeraki",server:"https://xxx.xxx.com",site:"xxx blog"})</script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/aeraki title=aeraki>aeraki
</a><a href=/tags/aeraki-mesh title="aeraki mesh">aeraki mesh
</a><a href=/tags/ambient-mesh title="ambient mesh">ambient mesh
</a><a href=/tags/api-gateway title="api gateway">api gateway
</a><a href=/tags/bitcoin title=bitcoin>bitcoin
</a><a href=/tags/blockchain title=blockchain>blockchain
</a><a href=/tags/cka title=cka>cka
</a><a href=/tags/cncf title=cncf>cncf
</a><a href=/tags/cryptocurrency title=cryptocurrency>cryptocurrency
</a><a href=/tags/digital-signature title="digital signature">digital signature
</a><a href=/tags/docker title=docker>docker
</a><a href=/tags/dubbo title=dubbo>dubbo
</a><a href=/tags/envoy title=envoy>envoy
</a><a href=/tags/envoy-gateway title="envoy gateway">envoy gateway
</a><a href=/tags/ingress title=ingress>ingress
</a><a href=/tags/istio title=istio>istio
</a><a href=/tags/jaeger title=jaeger>jaeger
</a><a href=/tags/kafka title=kafka>kafka
</a><a href=/tags/knowledge-graph title="knowledge graph">knowledge graph
</a><a href=/tags/kubecon title=kubecon>kubecon
</a><a href=/tags/kubernetes title=kubernetes>kubernetes
</a><a href=/tags/linux title=linux>linux
</a><a href=/tags/loadbalancer title=loadbalancer>loadbalancer
</a><a href=/tags/metaprotocol title=metaprotocol>metaprotocol
</a><a href=/tags/microservice title=microservice>microservice
</a><a href=/tags/network title=network>network
</a><a href=/tags/network-service-mesh title="network service mesh">network service mesh
</a><a href=/tags/nfv title=nfv>nfv
</a><a href=/tags/nodeport title=nodeport>nodeport
</a><a href=/tags/onap title=onap>onap
</a><a href=/tags/opentracing title=opentracing>opentracing
</a><a href=/tags/pilot title=pilot>pilot
</a><a href=/tags/proxy-protocol title="proxy protocol">proxy protocol
</a><a href=/tags/redis title=redis>redis
</a><a href=/tags/sdn title=sdn>sdn
</a><a href=/tags/security title=security>security
</a><a href=/tags/service-mesh title="service mesh">service mesh
</a><a href=/tags/tencent title=tencent>tencent
</a><a href=/tags/x-forwarded-for title=x-forwarded-for>x-forwarded-for</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:youremail@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/hugo-template/your%20wechat%20qr%20code%20image><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/yourgithub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/yourlinkedinid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/yourstackoverflowid><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Huabing Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Huabing Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/hugo-template/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>